ARM GAS  /tmp/cc74YnhY.s 			page 1


   1              		.cpu cortex-m4
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 1
  10              		.eabi_attribute 18, 4
  11              		.file	"stm32f4xx_pwr.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.PWR_DeInit,"ax",%progbits
  16              		.align	1
  17              		.global	PWR_DeInit
  18              		.syntax unified
  19              		.thumb
  20              		.thumb_func
  21              		.fpu softvfp
  23              	PWR_DeInit:
  24              	.LFB112:
  25              		.file 1 "FWLIB/src/stm32f4xx_pwr.c"
   1:FWLIB/src/stm32f4xx_pwr.c **** /**
   2:FWLIB/src/stm32f4xx_pwr.c ****   ******************************************************************************
   3:FWLIB/src/stm32f4xx_pwr.c ****   * @file    stm32f4xx_pwr.c
   4:FWLIB/src/stm32f4xx_pwr.c ****   * @author  MCD Application Team
   5:FWLIB/src/stm32f4xx_pwr.c ****   * @version V1.4.0
   6:FWLIB/src/stm32f4xx_pwr.c ****   * @date    04-August-2014
   7:FWLIB/src/stm32f4xx_pwr.c ****   * @brief   This file provides firmware functions to manage the following 
   8:FWLIB/src/stm32f4xx_pwr.c ****   *          functionalities of the Power Controller (PWR) peripheral:           
   9:FWLIB/src/stm32f4xx_pwr.c ****   *           + Backup Domain Access
  10:FWLIB/src/stm32f4xx_pwr.c ****   *           + PVD configuration
  11:FWLIB/src/stm32f4xx_pwr.c ****   *           + WakeUp pin configuration
  12:FWLIB/src/stm32f4xx_pwr.c ****   *           + Main and Backup Regulators configuration
  13:FWLIB/src/stm32f4xx_pwr.c ****   *           + FLASH Power Down configuration
  14:FWLIB/src/stm32f4xx_pwr.c ****   *           + Low Power modes configuration
  15:FWLIB/src/stm32f4xx_pwr.c ****   *           + Flags management
  16:FWLIB/src/stm32f4xx_pwr.c ****   *               
  17:FWLIB/src/stm32f4xx_pwr.c ****   ******************************************************************************
  18:FWLIB/src/stm32f4xx_pwr.c ****   * @attention
  19:FWLIB/src/stm32f4xx_pwr.c ****   *
  20:FWLIB/src/stm32f4xx_pwr.c ****   * <h2><center>&copy; COPYRIGHT 2014 STMicroelectronics</center></h2>
  21:FWLIB/src/stm32f4xx_pwr.c ****   *
  22:FWLIB/src/stm32f4xx_pwr.c ****   * Licensed under MCD-ST Liberty SW License Agreement V2, (the "License");
  23:FWLIB/src/stm32f4xx_pwr.c ****   * You may not use this file except in compliance with the License.
  24:FWLIB/src/stm32f4xx_pwr.c ****   * You may obtain a copy of the License at:
  25:FWLIB/src/stm32f4xx_pwr.c ****   *
  26:FWLIB/src/stm32f4xx_pwr.c ****   *        http://www.st.com/software_license_agreement_liberty_v2
  27:FWLIB/src/stm32f4xx_pwr.c ****   *
  28:FWLIB/src/stm32f4xx_pwr.c ****   * Unless required by applicable law or agreed to in writing, software 
  29:FWLIB/src/stm32f4xx_pwr.c ****   * distributed under the License is distributed on an "AS IS" BASIS, 
  30:FWLIB/src/stm32f4xx_pwr.c ****   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
  31:FWLIB/src/stm32f4xx_pwr.c ****   * See the License for the specific language governing permissions and
  32:FWLIB/src/stm32f4xx_pwr.c ****   * limitations under the License.
  33:FWLIB/src/stm32f4xx_pwr.c ****   *
ARM GAS  /tmp/cc74YnhY.s 			page 2


  34:FWLIB/src/stm32f4xx_pwr.c ****   ******************************************************************************
  35:FWLIB/src/stm32f4xx_pwr.c ****   */ 
  36:FWLIB/src/stm32f4xx_pwr.c **** 
  37:FWLIB/src/stm32f4xx_pwr.c **** /* Includes ------------------------------------------------------------------*/
  38:FWLIB/src/stm32f4xx_pwr.c **** #include "stm32f4xx_pwr.h"
  39:FWLIB/src/stm32f4xx_pwr.c **** #include "stm32f4xx_rcc.h"
  40:FWLIB/src/stm32f4xx_pwr.c **** 
  41:FWLIB/src/stm32f4xx_pwr.c **** /** @addtogroup STM32F4xx_StdPeriph_Driver
  42:FWLIB/src/stm32f4xx_pwr.c ****   * @{
  43:FWLIB/src/stm32f4xx_pwr.c ****   */
  44:FWLIB/src/stm32f4xx_pwr.c **** 
  45:FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR 
  46:FWLIB/src/stm32f4xx_pwr.c ****   * @brief PWR driver modules
  47:FWLIB/src/stm32f4xx_pwr.c ****   * @{
  48:FWLIB/src/stm32f4xx_pwr.c ****   */ 
  49:FWLIB/src/stm32f4xx_pwr.c **** 
  50:FWLIB/src/stm32f4xx_pwr.c **** /* Private typedef -----------------------------------------------------------*/
  51:FWLIB/src/stm32f4xx_pwr.c **** /* Private define ------------------------------------------------------------*/
  52:FWLIB/src/stm32f4xx_pwr.c **** /* --------- PWR registers bit address in the alias region ---------- */
  53:FWLIB/src/stm32f4xx_pwr.c **** #define PWR_OFFSET               (PWR_BASE - PERIPH_BASE)
  54:FWLIB/src/stm32f4xx_pwr.c **** 
  55:FWLIB/src/stm32f4xx_pwr.c **** /* --- CR Register ---*/
  56:FWLIB/src/stm32f4xx_pwr.c **** 
  57:FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of DBP bit */
  58:FWLIB/src/stm32f4xx_pwr.c **** #define CR_OFFSET                (PWR_OFFSET + 0x00)
  59:FWLIB/src/stm32f4xx_pwr.c **** #define DBP_BitNumber            0x08
  60:FWLIB/src/stm32f4xx_pwr.c **** #define CR_DBP_BB                (PERIPH_BB_BASE + (CR_OFFSET * 32) + (DBP_BitNumber * 4))
  61:FWLIB/src/stm32f4xx_pwr.c **** 
  62:FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of PVDE bit */
  63:FWLIB/src/stm32f4xx_pwr.c **** #define PVDE_BitNumber           0x04
  64:FWLIB/src/stm32f4xx_pwr.c **** #define CR_PVDE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PVDE_BitNumber * 4))
  65:FWLIB/src/stm32f4xx_pwr.c **** 
  66:FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of FPDS bit */
  67:FWLIB/src/stm32f4xx_pwr.c **** #define FPDS_BitNumber           0x09
  68:FWLIB/src/stm32f4xx_pwr.c **** #define CR_FPDS_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (FPDS_BitNumber * 4))
  69:FWLIB/src/stm32f4xx_pwr.c **** 
  70:FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of PMODE bit */
  71:FWLIB/src/stm32f4xx_pwr.c **** #define PMODE_BitNumber           0x0E
  72:FWLIB/src/stm32f4xx_pwr.c **** #define CR_PMODE_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (PMODE_BitNumber * 4))
  73:FWLIB/src/stm32f4xx_pwr.c **** 
  74:FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of ODEN bit */
  75:FWLIB/src/stm32f4xx_pwr.c **** #define ODEN_BitNumber           0x10
  76:FWLIB/src/stm32f4xx_pwr.c **** #define CR_ODEN_BB               (PERIPH_BB_BASE + (CR_OFFSET * 32) + (ODEN_BitNumber * 4))
  77:FWLIB/src/stm32f4xx_pwr.c **** 
  78:FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of ODSWEN bit */
  79:FWLIB/src/stm32f4xx_pwr.c **** #define ODSWEN_BitNumber         0x11
  80:FWLIB/src/stm32f4xx_pwr.c **** #define CR_ODSWEN_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (ODSWEN_BitNumber * 4))
  81:FWLIB/src/stm32f4xx_pwr.c **** 
  82:FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of MRLVDS bit */
  83:FWLIB/src/stm32f4xx_pwr.c **** #define MRLVDS_BitNumber         0x0B
  84:FWLIB/src/stm32f4xx_pwr.c **** #define CR_MRLVDS_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (MRLVDS_BitNumber * 4))
  85:FWLIB/src/stm32f4xx_pwr.c **** 
  86:FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of LPLVDS bit */
  87:FWLIB/src/stm32f4xx_pwr.c **** #define LPLVDS_BitNumber         0x0A
  88:FWLIB/src/stm32f4xx_pwr.c **** #define CR_LPLVDS_BB             (PERIPH_BB_BASE + (CR_OFFSET * 32) + (LPLVDS_BitNumber * 4))
  89:FWLIB/src/stm32f4xx_pwr.c **** 
  90:FWLIB/src/stm32f4xx_pwr.c **** /* --- CSR Register ---*/
ARM GAS  /tmp/cc74YnhY.s 			page 3


  91:FWLIB/src/stm32f4xx_pwr.c **** 
  92:FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of EWUP bit */
  93:FWLIB/src/stm32f4xx_pwr.c **** #define CSR_OFFSET               (PWR_OFFSET + 0x04)
  94:FWLIB/src/stm32f4xx_pwr.c **** #define EWUP_BitNumber           0x08
  95:FWLIB/src/stm32f4xx_pwr.c **** #define CSR_EWUP_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (EWUP_BitNumber * 4))
  96:FWLIB/src/stm32f4xx_pwr.c **** 
  97:FWLIB/src/stm32f4xx_pwr.c **** /* Alias word address of BRE bit */
  98:FWLIB/src/stm32f4xx_pwr.c **** #define BRE_BitNumber            0x09
  99:FWLIB/src/stm32f4xx_pwr.c **** #define CSR_BRE_BB              (PERIPH_BB_BASE + (CSR_OFFSET * 32) + (BRE_BitNumber * 4))
 100:FWLIB/src/stm32f4xx_pwr.c **** 
 101:FWLIB/src/stm32f4xx_pwr.c **** /* ------------------ PWR registers bit mask ------------------------ */
 102:FWLIB/src/stm32f4xx_pwr.c **** 
 103:FWLIB/src/stm32f4xx_pwr.c **** /* CR register bit mask */
 104:FWLIB/src/stm32f4xx_pwr.c **** #define CR_DS_MASK               ((uint32_t)0xFFFFF3FC)
 105:FWLIB/src/stm32f4xx_pwr.c **** #define CR_PLS_MASK              ((uint32_t)0xFFFFFF1F)
 106:FWLIB/src/stm32f4xx_pwr.c **** #define CR_VOS_MASK              ((uint32_t)0xFFFF3FFF)
 107:FWLIB/src/stm32f4xx_pwr.c **** 
 108:FWLIB/src/stm32f4xx_pwr.c **** /* Private macro -------------------------------------------------------------*/
 109:FWLIB/src/stm32f4xx_pwr.c **** /* Private variables ---------------------------------------------------------*/
 110:FWLIB/src/stm32f4xx_pwr.c **** /* Private function prototypes -----------------------------------------------*/
 111:FWLIB/src/stm32f4xx_pwr.c **** /* Private functions ---------------------------------------------------------*/
 112:FWLIB/src/stm32f4xx_pwr.c **** 
 113:FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Private_Functions
 114:FWLIB/src/stm32f4xx_pwr.c ****   * @{
 115:FWLIB/src/stm32f4xx_pwr.c ****   */
 116:FWLIB/src/stm32f4xx_pwr.c **** 
 117:FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group1 Backup Domain Access function 
 118:FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   Backup Domain Access function  
 119:FWLIB/src/stm32f4xx_pwr.c ****  *
 120:FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 121:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 122:FWLIB/src/stm32f4xx_pwr.c ****                   ##### Backup Domain Access function #####
 123:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 124:FWLIB/src/stm32f4xx_pwr.c ****     [..]
 125:FWLIB/src/stm32f4xx_pwr.c ****       After reset, the backup domain (RTC registers, RTC backup data 
 126:FWLIB/src/stm32f4xx_pwr.c ****       registers and backup SRAM) is protected against possible unwanted 
 127:FWLIB/src/stm32f4xx_pwr.c ****       write accesses. 
 128:FWLIB/src/stm32f4xx_pwr.c ****       To enable access to the RTC Domain and RTC registers, proceed as follows:
 129:FWLIB/src/stm32f4xx_pwr.c ****         (+) Enable the Power Controller (PWR) APB1 interface clock using the
 130:FWLIB/src/stm32f4xx_pwr.c ****             RCC_APB1PeriphClockCmd() function.
 131:FWLIB/src/stm32f4xx_pwr.c ****         (+) Enable access to RTC domain using the PWR_BackupAccessCmd() function.
 132:FWLIB/src/stm32f4xx_pwr.c **** 
 133:FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 134:FWLIB/src/stm32f4xx_pwr.c ****   * @{
 135:FWLIB/src/stm32f4xx_pwr.c ****   */
 136:FWLIB/src/stm32f4xx_pwr.c **** 
 137:FWLIB/src/stm32f4xx_pwr.c **** /**
 138:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Deinitializes the PWR peripheral registers to their default reset values.     
 139:FWLIB/src/stm32f4xx_pwr.c ****   * @param  None
 140:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 141:FWLIB/src/stm32f4xx_pwr.c ****   */
 142:FWLIB/src/stm32f4xx_pwr.c **** void PWR_DeInit(void)
 143:FWLIB/src/stm32f4xx_pwr.c **** {
  26              		.loc 1 143 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cc74YnhY.s 			page 4


  30 0000 08B5     		push	{r3, lr}
  31              	.LCFI0:
  32              		.cfi_def_cfa_offset 8
  33              		.cfi_offset 3, -8
  34              		.cfi_offset 14, -4
 144:FWLIB/src/stm32f4xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, ENABLE);
  35              		.loc 1 144 0
  36 0002 0121     		movs	r1, #1
  37 0004 4FF08050 		mov	r0, #268435456
  38 0008 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  39              	.LVL0:
 145:FWLIB/src/stm32f4xx_pwr.c ****   RCC_APB1PeriphResetCmd(RCC_APB1Periph_PWR, DISABLE);
  40              		.loc 1 145 0
  41 000c 0021     		movs	r1, #0
  42 000e 4FF08050 		mov	r0, #268435456
  43 0012 FFF7FEFF 		bl	RCC_APB1PeriphResetCmd
  44              	.LVL1:
  45 0016 08BD     		pop	{r3, pc}
  46              		.cfi_endproc
  47              	.LFE112:
  49              		.section	.text.PWR_BackupAccessCmd,"ax",%progbits
  50              		.align	1
  51              		.global	PWR_BackupAccessCmd
  52              		.syntax unified
  53              		.thumb
  54              		.thumb_func
  55              		.fpu softvfp
  57              	PWR_BackupAccessCmd:
  58              	.LFB113:
 146:FWLIB/src/stm32f4xx_pwr.c **** }
 147:FWLIB/src/stm32f4xx_pwr.c **** 
 148:FWLIB/src/stm32f4xx_pwr.c **** /**
 149:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables access to the backup domain (RTC registers, RTC 
 150:FWLIB/src/stm32f4xx_pwr.c ****   *         backup data registers and backup SRAM).
 151:FWLIB/src/stm32f4xx_pwr.c ****   * @note   If the HSE divided by 2, 3, ..31 is used as the RTC clock, the 
 152:FWLIB/src/stm32f4xx_pwr.c ****   *         Backup Domain Access should be kept enabled.
 153:FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the access to the backup domain.
 154:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 155:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 156:FWLIB/src/stm32f4xx_pwr.c ****   */
 157:FWLIB/src/stm32f4xx_pwr.c **** void PWR_BackupAccessCmd(FunctionalState NewState)
 158:FWLIB/src/stm32f4xx_pwr.c **** {
  59              		.loc 1 158 0
  60              		.cfi_startproc
  61              		@ args = 0, pretend = 0, frame = 0
  62              		@ frame_needed = 0, uses_anonymous_args = 0
  63              		@ link register save eliminated.
  64              	.LVL2:
 159:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 160:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 161:FWLIB/src/stm32f4xx_pwr.c ****   
 162:FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_DBP_BB = (uint32_t)NewState;
  65              		.loc 1 162 0
  66 0000 014B     		ldr	r3, .L4
  67 0002 1860     		str	r0, [r3]
  68 0004 7047     		bx	lr
  69              	.L5:
ARM GAS  /tmp/cc74YnhY.s 			page 5


  70 0006 00BF     		.align	2
  71              	.L4:
  72 0008 20000E42 		.word	1108213792
  73              		.cfi_endproc
  74              	.LFE113:
  76              		.section	.text.PWR_PVDLevelConfig,"ax",%progbits
  77              		.align	1
  78              		.global	PWR_PVDLevelConfig
  79              		.syntax unified
  80              		.thumb
  81              		.thumb_func
  82              		.fpu softvfp
  84              	PWR_PVDLevelConfig:
  85              	.LFB114:
 163:FWLIB/src/stm32f4xx_pwr.c **** }
 164:FWLIB/src/stm32f4xx_pwr.c **** 
 165:FWLIB/src/stm32f4xx_pwr.c **** /**
 166:FWLIB/src/stm32f4xx_pwr.c ****   * @}
 167:FWLIB/src/stm32f4xx_pwr.c ****   */
 168:FWLIB/src/stm32f4xx_pwr.c **** 
 169:FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group2 PVD configuration functions
 170:FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   PVD configuration functions 
 171:FWLIB/src/stm32f4xx_pwr.c ****  *
 172:FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 173:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 174:FWLIB/src/stm32f4xx_pwr.c ****                     ##### PVD configuration functions #####
 175:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 176:FWLIB/src/stm32f4xx_pwr.c ****     [..]
 177:FWLIB/src/stm32f4xx_pwr.c ****       (+) The PVD is used to monitor the VDD power supply by comparing it to a 
 178:FWLIB/src/stm32f4xx_pwr.c ****           threshold selected by the PVD Level (PLS[2:0] bits in the PWR_CR).
 179:FWLIB/src/stm32f4xx_pwr.c ****       (+) A PVDO flag is available to indicate if VDD/VDDA is higher or lower 
 180:FWLIB/src/stm32f4xx_pwr.c ****           than the PVD threshold. This event is internally connected to the EXTI 
 181:FWLIB/src/stm32f4xx_pwr.c ****           line16 and can generate an interrupt if enabled through the EXTI registers.
 182:FWLIB/src/stm32f4xx_pwr.c ****       (+) The PVD is stopped in Standby mode.
 183:FWLIB/src/stm32f4xx_pwr.c **** 
 184:FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 185:FWLIB/src/stm32f4xx_pwr.c ****   * @{
 186:FWLIB/src/stm32f4xx_pwr.c ****   */
 187:FWLIB/src/stm32f4xx_pwr.c **** 
 188:FWLIB/src/stm32f4xx_pwr.c **** /**
 189:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Configures the voltage threshold detected by the Power Voltage Detector(PVD).
 190:FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_PVDLevel: specifies the PVD detection level
 191:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 192:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_0
 193:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_1
 194:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_2
 195:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_3
 196:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_4
 197:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_5
 198:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_6
 199:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_PVDLevel_7
 200:FWLIB/src/stm32f4xx_pwr.c ****   * @note   Refer to the electrical characteristics of your device datasheet for
 201:FWLIB/src/stm32f4xx_pwr.c ****   *         more details about the voltage threshold corresponding to each 
 202:FWLIB/src/stm32f4xx_pwr.c ****   *         detection level.
 203:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 204:FWLIB/src/stm32f4xx_pwr.c ****   */
 205:FWLIB/src/stm32f4xx_pwr.c **** void PWR_PVDLevelConfig(uint32_t PWR_PVDLevel)
ARM GAS  /tmp/cc74YnhY.s 			page 6


 206:FWLIB/src/stm32f4xx_pwr.c **** {
  86              		.loc 1 206 0
  87              		.cfi_startproc
  88              		@ args = 0, pretend = 0, frame = 0
  89              		@ frame_needed = 0, uses_anonymous_args = 0
  90              		@ link register save eliminated.
  91              	.LVL3:
 207:FWLIB/src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 208:FWLIB/src/stm32f4xx_pwr.c ****   
 209:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 210:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_PVD_LEVEL(PWR_PVDLevel));
 211:FWLIB/src/stm32f4xx_pwr.c ****   
 212:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
  92              		.loc 1 212 0
  93 0000 034A     		ldr	r2, .L7
  94 0002 1368     		ldr	r3, [r2]
  95              	.LVL4:
 213:FWLIB/src/stm32f4xx_pwr.c ****   
 214:FWLIB/src/stm32f4xx_pwr.c ****   /* Clear PLS[7:5] bits */
 215:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg &= CR_PLS_MASK;
  96              		.loc 1 215 0
  97 0004 23F0E003 		bic	r3, r3, #224
  98              	.LVL5:
 216:FWLIB/src/stm32f4xx_pwr.c ****   
 217:FWLIB/src/stm32f4xx_pwr.c ****   /* Set PLS[7:5] bits according to PWR_PVDLevel value */
 218:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg |= PWR_PVDLevel;
  99              		.loc 1 218 0
 100 0008 1843     		orrs	r0, r0, r3
 101              	.LVL6:
 219:FWLIB/src/stm32f4xx_pwr.c ****   
 220:FWLIB/src/stm32f4xx_pwr.c ****   /* Store the new value */
 221:FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 102              		.loc 1 221 0
 103 000a 1060     		str	r0, [r2]
 104 000c 7047     		bx	lr
 105              	.L8:
 106 000e 00BF     		.align	2
 107              	.L7:
 108 0010 00700040 		.word	1073770496
 109              		.cfi_endproc
 110              	.LFE114:
 112              		.section	.text.PWR_PVDCmd,"ax",%progbits
 113              		.align	1
 114              		.global	PWR_PVDCmd
 115              		.syntax unified
 116              		.thumb
 117              		.thumb_func
 118              		.fpu softvfp
 120              	PWR_PVDCmd:
 121              	.LFB115:
 222:FWLIB/src/stm32f4xx_pwr.c **** }
 223:FWLIB/src/stm32f4xx_pwr.c **** 
 224:FWLIB/src/stm32f4xx_pwr.c **** /**
 225:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Power Voltage Detector(PVD).
 226:FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the PVD.
 227:FWLIB/src/stm32f4xx_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 228:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
ARM GAS  /tmp/cc74YnhY.s 			page 7


 229:FWLIB/src/stm32f4xx_pwr.c ****   */
 230:FWLIB/src/stm32f4xx_pwr.c **** void PWR_PVDCmd(FunctionalState NewState)
 231:FWLIB/src/stm32f4xx_pwr.c **** {
 122              		.loc 1 231 0
 123              		.cfi_startproc
 124              		@ args = 0, pretend = 0, frame = 0
 125              		@ frame_needed = 0, uses_anonymous_args = 0
 126              		@ link register save eliminated.
 127              	.LVL7:
 232:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 233:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 234:FWLIB/src/stm32f4xx_pwr.c ****   
 235:FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_PVDE_BB = (uint32_t)NewState;
 128              		.loc 1 235 0
 129 0000 014B     		ldr	r3, .L10
 130 0002 1860     		str	r0, [r3]
 131 0004 7047     		bx	lr
 132              	.L11:
 133 0006 00BF     		.align	2
 134              	.L10:
 135 0008 10000E42 		.word	1108213776
 136              		.cfi_endproc
 137              	.LFE115:
 139              		.section	.text.PWR_WakeUpPinCmd,"ax",%progbits
 140              		.align	1
 141              		.global	PWR_WakeUpPinCmd
 142              		.syntax unified
 143              		.thumb
 144              		.thumb_func
 145              		.fpu softvfp
 147              	PWR_WakeUpPinCmd:
 148              	.LFB116:
 236:FWLIB/src/stm32f4xx_pwr.c **** }
 237:FWLIB/src/stm32f4xx_pwr.c **** 
 238:FWLIB/src/stm32f4xx_pwr.c **** /**
 239:FWLIB/src/stm32f4xx_pwr.c ****   * @}
 240:FWLIB/src/stm32f4xx_pwr.c ****   */
 241:FWLIB/src/stm32f4xx_pwr.c **** 
 242:FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group3 WakeUp pin configuration functions
 243:FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   WakeUp pin configuration functions 
 244:FWLIB/src/stm32f4xx_pwr.c ****  *
 245:FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 246:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 247:FWLIB/src/stm32f4xx_pwr.c ****                  ##### WakeUp pin configuration functions #####
 248:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 249:FWLIB/src/stm32f4xx_pwr.c ****     [..]
 250:FWLIB/src/stm32f4xx_pwr.c ****       (+) WakeUp pin is used to wakeup the system from Standby mode. This pin is 
 251:FWLIB/src/stm32f4xx_pwr.c ****           forced in input pull down configuration and is active on rising edges.
 252:FWLIB/src/stm32f4xx_pwr.c ****       (+) There is only one WakeUp pin: WakeUp Pin 1 on PA.00.
 253:FWLIB/src/stm32f4xx_pwr.c **** 
 254:FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 255:FWLIB/src/stm32f4xx_pwr.c ****   * @{
 256:FWLIB/src/stm32f4xx_pwr.c ****   */
 257:FWLIB/src/stm32f4xx_pwr.c **** 
 258:FWLIB/src/stm32f4xx_pwr.c **** /**
 259:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the WakeUp Pin functionality.
 260:FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the WakeUp Pin functionality.
ARM GAS  /tmp/cc74YnhY.s 			page 8


 261:FWLIB/src/stm32f4xx_pwr.c ****   *         This parameter can be: ENABLE or DISABLE.
 262:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 263:FWLIB/src/stm32f4xx_pwr.c ****   */
 264:FWLIB/src/stm32f4xx_pwr.c **** void PWR_WakeUpPinCmd(FunctionalState NewState)
 265:FWLIB/src/stm32f4xx_pwr.c **** {
 149              		.loc 1 265 0
 150              		.cfi_startproc
 151              		@ args = 0, pretend = 0, frame = 0
 152              		@ frame_needed = 0, uses_anonymous_args = 0
 153              		@ link register save eliminated.
 154              	.LVL8:
 266:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */  
 267:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 268:FWLIB/src/stm32f4xx_pwr.c **** 
 269:FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CSR_EWUP_BB = (uint32_t)NewState;
 155              		.loc 1 269 0
 156 0000 014B     		ldr	r3, .L13
 157 0002 1860     		str	r0, [r3]
 158 0004 7047     		bx	lr
 159              	.L14:
 160 0006 00BF     		.align	2
 161              	.L13:
 162 0008 A0000E42 		.word	1108213920
 163              		.cfi_endproc
 164              	.LFE116:
 166              		.section	.text.PWR_BackupRegulatorCmd,"ax",%progbits
 167              		.align	1
 168              		.global	PWR_BackupRegulatorCmd
 169              		.syntax unified
 170              		.thumb
 171              		.thumb_func
 172              		.fpu softvfp
 174              	PWR_BackupRegulatorCmd:
 175              	.LFB117:
 270:FWLIB/src/stm32f4xx_pwr.c **** }
 271:FWLIB/src/stm32f4xx_pwr.c **** 
 272:FWLIB/src/stm32f4xx_pwr.c **** /**
 273:FWLIB/src/stm32f4xx_pwr.c ****   * @}
 274:FWLIB/src/stm32f4xx_pwr.c ****   */
 275:FWLIB/src/stm32f4xx_pwr.c **** 
 276:FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group4 Main and Backup Regulators configuration functions
 277:FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   Main and Backup Regulators configuration functions 
 278:FWLIB/src/stm32f4xx_pwr.c ****  *
 279:FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 280:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 281:FWLIB/src/stm32f4xx_pwr.c ****           ##### Main and Backup Regulators configuration functions #####
 282:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 283:FWLIB/src/stm32f4xx_pwr.c ****     [..]
 284:FWLIB/src/stm32f4xx_pwr.c ****       (+) The backup domain includes 4 Kbytes of backup SRAM accessible only from 
 285:FWLIB/src/stm32f4xx_pwr.c ****           the CPU, and address in 32-bit, 16-bit or 8-bit mode. Its content is 
 286:FWLIB/src/stm32f4xx_pwr.c ****           retained even in Standby or VBAT mode when the low power backup regulator
 287:FWLIB/src/stm32f4xx_pwr.c ****           is enabled. It can be considered as an internal EEPROM when VBAT is 
 288:FWLIB/src/stm32f4xx_pwr.c ****           always present. You can use the PWR_BackupRegulatorCmd() function to 
 289:FWLIB/src/stm32f4xx_pwr.c ****           enable the low power backup regulator and use the PWR_GetFlagStatus
 290:FWLIB/src/stm32f4xx_pwr.c ****           (PWR_FLAG_BRR) to check if it is ready or not. 
 291:FWLIB/src/stm32f4xx_pwr.c **** 
 292:FWLIB/src/stm32f4xx_pwr.c ****       (+) When the backup domain is supplied by VDD (analog switch connected to VDD) 
ARM GAS  /tmp/cc74YnhY.s 			page 9


 293:FWLIB/src/stm32f4xx_pwr.c ****           the backup SRAM is powered from VDD which replaces the VBAT power supply to 
 294:FWLIB/src/stm32f4xx_pwr.c ****           save battery life.
 295:FWLIB/src/stm32f4xx_pwr.c **** 
 296:FWLIB/src/stm32f4xx_pwr.c ****       (+) The backup SRAM is not mass erased by an tamper event. It is read 
 297:FWLIB/src/stm32f4xx_pwr.c ****           protected to prevent confidential data, such as cryptographic private 
 298:FWLIB/src/stm32f4xx_pwr.c ****           key, from being accessed. The backup SRAM can be erased only through 
 299:FWLIB/src/stm32f4xx_pwr.c ****           the Flash interface when a protection level change from level 1 to 
 300:FWLIB/src/stm32f4xx_pwr.c ****           level 0 is requested. 
 301:FWLIB/src/stm32f4xx_pwr.c ****       -@- Refer to the description of Read protection (RDP) in the reference manual.
 302:FWLIB/src/stm32f4xx_pwr.c **** 
 303:FWLIB/src/stm32f4xx_pwr.c ****       (+) The main internal regulator can be configured to have a tradeoff between 
 304:FWLIB/src/stm32f4xx_pwr.c ****           performance and power consumption when the device does not operate at 
 305:FWLIB/src/stm32f4xx_pwr.c ****           the maximum frequency. 
 306:FWLIB/src/stm32f4xx_pwr.c ****       (+) For STM32F405xx/407xx and STM32F415xx/417xx  Devices, the regulator can be     
 307:FWLIB/src/stm32f4xx_pwr.c ****           configured on the fly through PWR_MainRegulatorModeConfig() function which  
 308:FWLIB/src/stm32f4xx_pwr.c ****           configure VOS bit in PWR_CR register:
 309:FWLIB/src/stm32f4xx_pwr.c ****         (++) When this bit is set (Regulator voltage output Scale 1 mode selected) 
 310:FWLIB/src/stm32f4xx_pwr.c ****              the System frequency can go up to 168 MHz. 
 311:FWLIB/src/stm32f4xx_pwr.c ****         (++) When this bit is reset (Regulator voltage output Scale 2 mode selected) 
 312:FWLIB/src/stm32f4xx_pwr.c ****              the System frequency can go up to 144 MHz.
 313:FWLIB/src/stm32f4xx_pwr.c ****              
 314:FWLIB/src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, the regulator can be configured through    
 315:FWLIB/src/stm32f4xx_pwr.c ****            PWR_MainRegulatorModeConfig() function which configure VOS[1:0] bits in
 316:FWLIB/src/stm32f4xx_pwr.c ****            PWR_CR register:  
 317:FWLIB/src/stm32f4xx_pwr.c ****            which configure VOS[1:0] bits in PWR_CR register: 
 318:FWLIB/src/stm32f4xx_pwr.c ****         (++) When VOS[1:0] = 11 (Regulator voltage output Scale 1 mode selected) 
 319:FWLIB/src/stm32f4xx_pwr.c ****              the System frequency can go up to 168 MHz. 
 320:FWLIB/src/stm32f4xx_pwr.c ****         (++) When VOS[1:0] = 10 (Regulator voltage output Scale 2 mode selected) 
 321:FWLIB/src/stm32f4xx_pwr.c ****              the System frequency can go up to 144 MHz.  
 322:FWLIB/src/stm32f4xx_pwr.c ****         (++) When VOS[1:0] = 01 (Regulator voltage output Scale 3 mode selected) 
 323:FWLIB/src/stm32f4xx_pwr.c ****              the System frequency can go up to 120 MHz. 
 324:FWLIB/src/stm32f4xx_pwr.c ****                           
 325:FWLIB/src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, the scale can be modified only when the PLL 
 326:FWLIB/src/stm32f4xx_pwr.c ****            is OFF and the HSI or HSE clock source is selected as system clock. 
 327:FWLIB/src/stm32f4xx_pwr.c ****            The new value programmed is active only when the PLL is ON.
 328:FWLIB/src/stm32f4xx_pwr.c ****            When the PLL is OFF, the voltage scale 3 is automatically selected. 
 329:FWLIB/src/stm32f4xx_pwr.c ****         Refer to the datasheets for more details.
 330:FWLIB/src/stm32f4xx_pwr.c ****         
 331:FWLIB/src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, in Run mode: the main regulator has
 332:FWLIB/src/stm32f4xx_pwr.c ****            2 operating modes available:
 333:FWLIB/src/stm32f4xx_pwr.c ****         (++) Normal mode: The CPU and core logic operate at maximum frequency at a given 
 334:FWLIB/src/stm32f4xx_pwr.c ****              voltage scaling (scale 1, scale 2 or scale 3)
 335:FWLIB/src/stm32f4xx_pwr.c ****         (++) Over-drive mode: This mode allows the CPU and the core logic to operate at a 
 336:FWLIB/src/stm32f4xx_pwr.c ****             higher frequency than the normal mode for a given voltage scaling (scale 1,  
 337:FWLIB/src/stm32f4xx_pwr.c ****             scale 2 or scale 3). This mode is enabled through PWR_OverDriveCmd() function and
 338:FWLIB/src/stm32f4xx_pwr.c ****             PWR_OverDriveSWCmd() function, to enter or exit from Over-drive mode please follow 
 339:FWLIB/src/stm32f4xx_pwr.c ****             the sequence described in Reference manual.
 340:FWLIB/src/stm32f4xx_pwr.c ****              
 341:FWLIB/src/stm32f4xx_pwr.c ****        (+) For STM32F42xxx/43xxx Devices, in Stop mode: the main regulator or low power regulator 
 342:FWLIB/src/stm32f4xx_pwr.c ****            supplies a low power voltage to the 1.2V domain, thus preserving the content of register
 343:FWLIB/src/stm32f4xx_pwr.c ****            and internal SRAM. 2 operating modes are available:
 344:FWLIB/src/stm32f4xx_pwr.c ****          (++) Normal mode: the 1.2V domain is preserved in nominal leakage mode. This mode is only 
 345:FWLIB/src/stm32f4xx_pwr.c ****               available when the main regulator or the low power regulator is used in Scale 3 or 
 346:FWLIB/src/stm32f4xx_pwr.c ****               low voltage mode.
 347:FWLIB/src/stm32f4xx_pwr.c ****          (++) Under-drive mode: the 1.2V domain is preserved in reduced leakage mode. This mode is 
 348:FWLIB/src/stm32f4xx_pwr.c ****               available when the main regulator or the low power regulator is in low voltage mode.
 349:FWLIB/src/stm32f4xx_pwr.c ****               This mode is enabled through PWR_UnderDriveCmd() function.
ARM GAS  /tmp/cc74YnhY.s 			page 10


 350:FWLIB/src/stm32f4xx_pwr.c ****             
 351:FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 352:FWLIB/src/stm32f4xx_pwr.c ****   * @{
 353:FWLIB/src/stm32f4xx_pwr.c ****   */
 354:FWLIB/src/stm32f4xx_pwr.c **** 
 355:FWLIB/src/stm32f4xx_pwr.c **** /**
 356:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Backup Regulator.
 357:FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Backup Regulator.
 358:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 359:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 360:FWLIB/src/stm32f4xx_pwr.c ****   */
 361:FWLIB/src/stm32f4xx_pwr.c **** void PWR_BackupRegulatorCmd(FunctionalState NewState)
 362:FWLIB/src/stm32f4xx_pwr.c **** {
 176              		.loc 1 362 0
 177              		.cfi_startproc
 178              		@ args = 0, pretend = 0, frame = 0
 179              		@ frame_needed = 0, uses_anonymous_args = 0
 180              		@ link register save eliminated.
 181              	.LVL9:
 363:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 364:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 365:FWLIB/src/stm32f4xx_pwr.c **** 
 366:FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CSR_BRE_BB = (uint32_t)NewState;
 182              		.loc 1 366 0
 183 0000 014B     		ldr	r3, .L16
 184 0002 1860     		str	r0, [r3]
 185 0004 7047     		bx	lr
 186              	.L17:
 187 0006 00BF     		.align	2
 188              	.L16:
 189 0008 A4000E42 		.word	1108213924
 190              		.cfi_endproc
 191              	.LFE117:
 193              		.section	.text.PWR_MainRegulatorModeConfig,"ax",%progbits
 194              		.align	1
 195              		.global	PWR_MainRegulatorModeConfig
 196              		.syntax unified
 197              		.thumb
 198              		.thumb_func
 199              		.fpu softvfp
 201              	PWR_MainRegulatorModeConfig:
 202              	.LFB118:
 367:FWLIB/src/stm32f4xx_pwr.c **** }
 368:FWLIB/src/stm32f4xx_pwr.c **** 
 369:FWLIB/src/stm32f4xx_pwr.c **** /**
 370:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Configures the main internal regulator output voltage.
 371:FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_Regulator_Voltage: specifies the regulator output voltage to achieve
 372:FWLIB/src/stm32f4xx_pwr.c ****   *         a tradeoff between performance and power consumption when the device does
 373:FWLIB/src/stm32f4xx_pwr.c ****   *         not operate at the maximum frequency (refer to the datasheets for more details).
 374:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 375:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_Voltage_Scale1: Regulator voltage output Scale 1 mode, 
 376:FWLIB/src/stm32f4xx_pwr.c ****   *                                                System frequency up to 168 MHz. 
 377:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_Voltage_Scale2: Regulator voltage output Scale 2 mode, 
 378:FWLIB/src/stm32f4xx_pwr.c ****   *                                                System frequency up to 144 MHz.    
 379:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_Regulator_Voltage_Scale3: Regulator voltage output Scale 3 mode, 
 380:FWLIB/src/stm32f4xx_pwr.c ****   *                                                System frequency up to 120 MHz (only for STM32F4
 381:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
ARM GAS  /tmp/cc74YnhY.s 			page 11


 382:FWLIB/src/stm32f4xx_pwr.c ****   */
 383:FWLIB/src/stm32f4xx_pwr.c **** void PWR_MainRegulatorModeConfig(uint32_t PWR_Regulator_Voltage)
 384:FWLIB/src/stm32f4xx_pwr.c **** {
 203              		.loc 1 384 0
 204              		.cfi_startproc
 205              		@ args = 0, pretend = 0, frame = 0
 206              		@ frame_needed = 0, uses_anonymous_args = 0
 207              		@ link register save eliminated.
 208              	.LVL10:
 385:FWLIB/src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 386:FWLIB/src/stm32f4xx_pwr.c **** 	
 387:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 388:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR_VOLTAGE(PWR_Regulator_Voltage));
 389:FWLIB/src/stm32f4xx_pwr.c **** 
 390:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 209              		.loc 1 390 0
 210 0000 034A     		ldr	r2, .L19
 211 0002 1368     		ldr	r3, [r2]
 212              	.LVL11:
 391:FWLIB/src/stm32f4xx_pwr.c ****   
 392:FWLIB/src/stm32f4xx_pwr.c ****   /* Clear VOS[15:14] bits */
 393:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg &= CR_VOS_MASK;
 213              		.loc 1 393 0
 214 0004 23F44043 		bic	r3, r3, #49152
 215              	.LVL12:
 394:FWLIB/src/stm32f4xx_pwr.c ****   
 395:FWLIB/src/stm32f4xx_pwr.c ****   /* Set VOS[15:14] bits according to PWR_Regulator_Voltage value */
 396:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg |= PWR_Regulator_Voltage;
 216              		.loc 1 396 0
 217 0008 1843     		orrs	r0, r0, r3
 218              	.LVL13:
 397:FWLIB/src/stm32f4xx_pwr.c ****   
 398:FWLIB/src/stm32f4xx_pwr.c ****   /* Store the new value */
 399:FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 219              		.loc 1 399 0
 220 000a 1060     		str	r0, [r2]
 221 000c 7047     		bx	lr
 222              	.L20:
 223 000e 00BF     		.align	2
 224              	.L19:
 225 0010 00700040 		.word	1073770496
 226              		.cfi_endproc
 227              	.LFE118:
 229              		.section	.text.PWR_OverDriveCmd,"ax",%progbits
 230              		.align	1
 231              		.global	PWR_OverDriveCmd
 232              		.syntax unified
 233              		.thumb
 234              		.thumb_func
 235              		.fpu softvfp
 237              	PWR_OverDriveCmd:
 238              	.LFB119:
 400:FWLIB/src/stm32f4xx_pwr.c **** }
 401:FWLIB/src/stm32f4xx_pwr.c **** 
 402:FWLIB/src/stm32f4xx_pwr.c **** /**
 403:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Over-Drive.
 404:FWLIB/src/stm32f4xx_pwr.c ****   * 
ARM GAS  /tmp/cc74YnhY.s 			page 12


 405:FWLIB/src/stm32f4xx_pwr.c ****   * @note   This function can be used only for STM32F42xxx/STM3243xxx devices.
 406:FWLIB/src/stm32f4xx_pwr.c ****   *         This mode allows the CPU and the core logic to operate at a higher frequency
 407:FWLIB/src/stm32f4xx_pwr.c ****   *         than the normal mode for a given voltage scaling (scale 1, scale 2 or scale 3).   
 408:FWLIB/src/stm32f4xx_pwr.c ****   * 
 409:FWLIB/src/stm32f4xx_pwr.c ****   * @note   It is recommended to enter or exit Over-drive mode when the application is not running 
 410:FWLIB/src/stm32f4xx_pwr.c ****   *          critical tasks and when the system clock source is either HSI or HSE. 
 411:FWLIB/src/stm32f4xx_pwr.c ****   *          During the Over-drive switch activation, no peripheral clocks should be enabled.   
 412:FWLIB/src/stm32f4xx_pwr.c ****   *          The peripheral clocks must be enabled once the Over-drive mode is activated.
 413:FWLIB/src/stm32f4xx_pwr.c ****   *            
 414:FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Over Drive mode.
 415:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 416:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 417:FWLIB/src/stm32f4xx_pwr.c ****   */
 418:FWLIB/src/stm32f4xx_pwr.c **** void PWR_OverDriveCmd(FunctionalState NewState)
 419:FWLIB/src/stm32f4xx_pwr.c **** {
 239              		.loc 1 419 0
 240              		.cfi_startproc
 241              		@ args = 0, pretend = 0, frame = 0
 242              		@ frame_needed = 0, uses_anonymous_args = 0
 243              		@ link register save eliminated.
 244              	.LVL14:
 420:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 421:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 422:FWLIB/src/stm32f4xx_pwr.c ****   
 423:FWLIB/src/stm32f4xx_pwr.c ****   /* Set/Reset the ODEN bit to enable/disable the Over Drive mode */
 424:FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_ODEN_BB = (uint32_t)NewState;
 245              		.loc 1 424 0
 246 0000 014B     		ldr	r3, .L22
 247 0002 1860     		str	r0, [r3]
 248 0004 7047     		bx	lr
 249              	.L23:
 250 0006 00BF     		.align	2
 251              	.L22:
 252 0008 40000E42 		.word	1108213824
 253              		.cfi_endproc
 254              	.LFE119:
 256              		.section	.text.PWR_OverDriveSWCmd,"ax",%progbits
 257              		.align	1
 258              		.global	PWR_OverDriveSWCmd
 259              		.syntax unified
 260              		.thumb
 261              		.thumb_func
 262              		.fpu softvfp
 264              	PWR_OverDriveSWCmd:
 265              	.LFB120:
 425:FWLIB/src/stm32f4xx_pwr.c **** }
 426:FWLIB/src/stm32f4xx_pwr.c **** 
 427:FWLIB/src/stm32f4xx_pwr.c **** /**
 428:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Over-Drive switching.
 429:FWLIB/src/stm32f4xx_pwr.c ****   * 
 430:FWLIB/src/stm32f4xx_pwr.c ****   * @note   This function can be used only for STM32F42xxx/STM3243xxx devices. 
 431:FWLIB/src/stm32f4xx_pwr.c ****   *       
 432:FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Over Drive switching mode.
 433:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 434:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 435:FWLIB/src/stm32f4xx_pwr.c ****   */
 436:FWLIB/src/stm32f4xx_pwr.c **** void PWR_OverDriveSWCmd(FunctionalState NewState)
ARM GAS  /tmp/cc74YnhY.s 			page 13


 437:FWLIB/src/stm32f4xx_pwr.c **** {
 266              		.loc 1 437 0
 267              		.cfi_startproc
 268              		@ args = 0, pretend = 0, frame = 0
 269              		@ frame_needed = 0, uses_anonymous_args = 0
 270              		@ link register save eliminated.
 271              	.LVL15:
 438:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 439:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 440:FWLIB/src/stm32f4xx_pwr.c **** 
 441:FWLIB/src/stm32f4xx_pwr.c ****   /* Set/Reset the ODSWEN bit to enable/disable the Over Drive switching mode */
 442:FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_ODSWEN_BB = (uint32_t)NewState;
 272              		.loc 1 442 0
 273 0000 014B     		ldr	r3, .L25
 274 0002 1860     		str	r0, [r3]
 275 0004 7047     		bx	lr
 276              	.L26:
 277 0006 00BF     		.align	2
 278              	.L25:
 279 0008 44000E42 		.word	1108213828
 280              		.cfi_endproc
 281              	.LFE120:
 283              		.section	.text.PWR_UnderDriveCmd,"ax",%progbits
 284              		.align	1
 285              		.global	PWR_UnderDriveCmd
 286              		.syntax unified
 287              		.thumb
 288              		.thumb_func
 289              		.fpu softvfp
 291              	PWR_UnderDriveCmd:
 292              	.LFB121:
 443:FWLIB/src/stm32f4xx_pwr.c **** }
 444:FWLIB/src/stm32f4xx_pwr.c **** 
 445:FWLIB/src/stm32f4xx_pwr.c **** /**
 446:FWLIB/src/stm32f4xx_pwr.c ****   * @brief   Enables or disables the Under-Drive mode.
 447:FWLIB/src/stm32f4xx_pwr.c ****   * 
 448:FWLIB/src/stm32f4xx_pwr.c ****   * @note   This function can be used only for STM32F42xxx/STM3243xxx devices.
 449:FWLIB/src/stm32f4xx_pwr.c ****   * @note    This mode is enabled only with STOP low power mode.
 450:FWLIB/src/stm32f4xx_pwr.c ****   *          In this mode, the 1.2V domain is preserved in reduced leakage mode. This 
 451:FWLIB/src/stm32f4xx_pwr.c ****   *          mode is only available when the main regulator or the low power regulator 
 452:FWLIB/src/stm32f4xx_pwr.c ****   *          is in low voltage mode
 453:FWLIB/src/stm32f4xx_pwr.c ****   *        
 454:FWLIB/src/stm32f4xx_pwr.c ****   * @note   If the Under-drive mode was enabled, it is automatically disabled after 
 455:FWLIB/src/stm32f4xx_pwr.c ****   *         exiting Stop mode. 
 456:FWLIB/src/stm32f4xx_pwr.c ****   *         When the voltage regulator operates in Under-drive mode, an additional  
 457:FWLIB/src/stm32f4xx_pwr.c ****   *         startup delay is induced when waking up from Stop mode.
 458:FWLIB/src/stm32f4xx_pwr.c ****   *                    
 459:FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Under Drive mode.
 460:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 461:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 462:FWLIB/src/stm32f4xx_pwr.c ****   */
 463:FWLIB/src/stm32f4xx_pwr.c **** void PWR_UnderDriveCmd(FunctionalState NewState)
 464:FWLIB/src/stm32f4xx_pwr.c **** {
 293              		.loc 1 464 0
 294              		.cfi_startproc
 295              		@ args = 0, pretend = 0, frame = 0
 296              		@ frame_needed = 0, uses_anonymous_args = 0
ARM GAS  /tmp/cc74YnhY.s 			page 14


 297              		@ link register save eliminated.
 298              	.LVL16:
 465:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 466:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 467:FWLIB/src/stm32f4xx_pwr.c **** 
 468:FWLIB/src/stm32f4xx_pwr.c ****   if (NewState != DISABLE)
 299              		.loc 1 468 0
 300 0000 28B9     		cbnz	r0, .L30
 469:FWLIB/src/stm32f4xx_pwr.c ****   {
 470:FWLIB/src/stm32f4xx_pwr.c ****     /* Set the UDEN[1:0] bits to enable the Under Drive mode */
 471:FWLIB/src/stm32f4xx_pwr.c ****     PWR->CR |= (uint32_t)PWR_CR_UDEN;
 472:FWLIB/src/stm32f4xx_pwr.c ****   }
 473:FWLIB/src/stm32f4xx_pwr.c ****   else
 474:FWLIB/src/stm32f4xx_pwr.c ****   {
 475:FWLIB/src/stm32f4xx_pwr.c ****     /* Reset the UDEN[1:0] bits to disable the Under Drive mode */
 476:FWLIB/src/stm32f4xx_pwr.c ****     PWR->CR &= (uint32_t)(~PWR_CR_UDEN);
 301              		.loc 1 476 0
 302 0002 064A     		ldr	r2, .L31
 303 0004 1368     		ldr	r3, [r2]
 304 0006 23F44023 		bic	r3, r3, #786432
 305 000a 1360     		str	r3, [r2]
 306 000c 7047     		bx	lr
 307              	.L30:
 471:FWLIB/src/stm32f4xx_pwr.c ****   }
 308              		.loc 1 471 0
 309 000e 034A     		ldr	r2, .L31
 310 0010 1368     		ldr	r3, [r2]
 311 0012 43F44023 		orr	r3, r3, #786432
 312 0016 1360     		str	r3, [r2]
 313 0018 7047     		bx	lr
 314              	.L32:
 315 001a 00BF     		.align	2
 316              	.L31:
 317 001c 00700040 		.word	1073770496
 318              		.cfi_endproc
 319              	.LFE121:
 321              		.section	.text.PWR_MainRegulatorLowVoltageCmd,"ax",%progbits
 322              		.align	1
 323              		.global	PWR_MainRegulatorLowVoltageCmd
 324              		.syntax unified
 325              		.thumb
 326              		.thumb_func
 327              		.fpu softvfp
 329              	PWR_MainRegulatorLowVoltageCmd:
 330              	.LFB122:
 477:FWLIB/src/stm32f4xx_pwr.c ****   }
 478:FWLIB/src/stm32f4xx_pwr.c **** }
 479:FWLIB/src/stm32f4xx_pwr.c **** 
 480:FWLIB/src/stm32f4xx_pwr.c **** /**
 481:FWLIB/src/stm32f4xx_pwr.c ****   * @brief Enables or disables the Main Regulator low voltage mode.
 482:FWLIB/src/stm32f4xx_pwr.c ****   *
 483:FWLIB/src/stm32f4xx_pwr.c ****   * @note  This mode is only available for STM32F401xx/STM32F411xx devices.
 484:FWLIB/src/stm32f4xx_pwr.c ****   *
 485:FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Under Drive mode.
 486:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 487:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 488:FWLIB/src/stm32f4xx_pwr.c ****   */
ARM GAS  /tmp/cc74YnhY.s 			page 15


 489:FWLIB/src/stm32f4xx_pwr.c **** void PWR_MainRegulatorLowVoltageCmd(FunctionalState NewState)
 490:FWLIB/src/stm32f4xx_pwr.c **** { 
 331              		.loc 1 490 0
 332              		.cfi_startproc
 333              		@ args = 0, pretend = 0, frame = 0
 334              		@ frame_needed = 0, uses_anonymous_args = 0
 335              		@ link register save eliminated.
 336              	.LVL17:
 491:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 492:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 493:FWLIB/src/stm32f4xx_pwr.c ****   
 494:FWLIB/src/stm32f4xx_pwr.c ****   if (NewState != DISABLE)
 337              		.loc 1 494 0
 338 0000 18B9     		cbnz	r0, .L36
 495:FWLIB/src/stm32f4xx_pwr.c ****   {
 496:FWLIB/src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)ENABLE;
 497:FWLIB/src/stm32f4xx_pwr.c ****   }
 498:FWLIB/src/stm32f4xx_pwr.c ****   else
 499:FWLIB/src/stm32f4xx_pwr.c ****   {
 500:FWLIB/src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_MRLVDS_BB = (uint32_t)DISABLE;
 339              		.loc 1 500 0
 340 0002 0022     		movs	r2, #0
 341 0004 034B     		ldr	r3, .L37
 342 0006 1A60     		str	r2, [r3]
 343 0008 7047     		bx	lr
 344              	.L36:
 496:FWLIB/src/stm32f4xx_pwr.c ****   }
 345              		.loc 1 496 0
 346 000a 0122     		movs	r2, #1
 347 000c 014B     		ldr	r3, .L37
 348 000e 1A60     		str	r2, [r3]
 349 0010 7047     		bx	lr
 350              	.L38:
 351 0012 00BF     		.align	2
 352              	.L37:
 353 0014 2C000E42 		.word	1108213804
 354              		.cfi_endproc
 355              	.LFE122:
 357              		.section	.text.PWR_LowRegulatorLowVoltageCmd,"ax",%progbits
 358              		.align	1
 359              		.global	PWR_LowRegulatorLowVoltageCmd
 360              		.syntax unified
 361              		.thumb
 362              		.thumb_func
 363              		.fpu softvfp
 365              	PWR_LowRegulatorLowVoltageCmd:
 366              	.LFB123:
 501:FWLIB/src/stm32f4xx_pwr.c ****   }
 502:FWLIB/src/stm32f4xx_pwr.c **** }
 503:FWLIB/src/stm32f4xx_pwr.c **** 
 504:FWLIB/src/stm32f4xx_pwr.c **** /**
 505:FWLIB/src/stm32f4xx_pwr.c ****   * @brief Enables or disables the Low Power Regulator low voltage mode.
 506:FWLIB/src/stm32f4xx_pwr.c ****   *
 507:FWLIB/src/stm32f4xx_pwr.c ****   * @note  This mode is only available for STM32F401xx/STM32F411xx devices.
 508:FWLIB/src/stm32f4xx_pwr.c ****   *
 509:FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Under Drive mode.
 510:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
ARM GAS  /tmp/cc74YnhY.s 			page 16


 511:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 512:FWLIB/src/stm32f4xx_pwr.c ****   */
 513:FWLIB/src/stm32f4xx_pwr.c **** void PWR_LowRegulatorLowVoltageCmd(FunctionalState NewState)
 514:FWLIB/src/stm32f4xx_pwr.c **** {
 367              		.loc 1 514 0
 368              		.cfi_startproc
 369              		@ args = 0, pretend = 0, frame = 0
 370              		@ frame_needed = 0, uses_anonymous_args = 0
 371              		@ link register save eliminated.
 372              	.LVL18:
 515:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 516:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 517:FWLIB/src/stm32f4xx_pwr.c ****   
 518:FWLIB/src/stm32f4xx_pwr.c ****   if (NewState != DISABLE)
 373              		.loc 1 518 0
 374 0000 18B9     		cbnz	r0, .L42
 519:FWLIB/src/stm32f4xx_pwr.c ****   {
 520:FWLIB/src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)ENABLE;
 521:FWLIB/src/stm32f4xx_pwr.c ****   }
 522:FWLIB/src/stm32f4xx_pwr.c ****   else
 523:FWLIB/src/stm32f4xx_pwr.c ****   {
 524:FWLIB/src/stm32f4xx_pwr.c ****     *(__IO uint32_t *) CR_LPLVDS_BB = (uint32_t)DISABLE;
 375              		.loc 1 524 0
 376 0002 0022     		movs	r2, #0
 377 0004 034B     		ldr	r3, .L43
 378 0006 1A60     		str	r2, [r3]
 379 0008 7047     		bx	lr
 380              	.L42:
 520:FWLIB/src/stm32f4xx_pwr.c ****   }
 381              		.loc 1 520 0
 382 000a 0122     		movs	r2, #1
 383 000c 014B     		ldr	r3, .L43
 384 000e 1A60     		str	r2, [r3]
 385 0010 7047     		bx	lr
 386              	.L44:
 387 0012 00BF     		.align	2
 388              	.L43:
 389 0014 28000E42 		.word	1108213800
 390              		.cfi_endproc
 391              	.LFE123:
 393              		.section	.text.PWR_FlashPowerDownCmd,"ax",%progbits
 394              		.align	1
 395              		.global	PWR_FlashPowerDownCmd
 396              		.syntax unified
 397              		.thumb
 398              		.thumb_func
 399              		.fpu softvfp
 401              	PWR_FlashPowerDownCmd:
 402              	.LFB124:
 525:FWLIB/src/stm32f4xx_pwr.c ****   }
 526:FWLIB/src/stm32f4xx_pwr.c **** }
 527:FWLIB/src/stm32f4xx_pwr.c **** 
 528:FWLIB/src/stm32f4xx_pwr.c **** /**
 529:FWLIB/src/stm32f4xx_pwr.c ****   * @}
 530:FWLIB/src/stm32f4xx_pwr.c ****   */
 531:FWLIB/src/stm32f4xx_pwr.c **** 
 532:FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group5 FLASH Power Down configuration functions
ARM GAS  /tmp/cc74YnhY.s 			page 17


 533:FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   FLASH Power Down configuration functions 
 534:FWLIB/src/stm32f4xx_pwr.c ****  *
 535:FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 536:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 537:FWLIB/src/stm32f4xx_pwr.c ****              ##### FLASH Power Down configuration functions #####
 538:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 539:FWLIB/src/stm32f4xx_pwr.c ****     [..]
 540:FWLIB/src/stm32f4xx_pwr.c ****       (+) By setting the FPDS bit in the PWR_CR register by using the 
 541:FWLIB/src/stm32f4xx_pwr.c ****           PWR_FlashPowerDownCmd() function, the Flash memory also enters power 
 542:FWLIB/src/stm32f4xx_pwr.c ****           down mode when the device enters Stop mode. When the Flash memory 
 543:FWLIB/src/stm32f4xx_pwr.c ****           is in power down mode, an additional startup delay is incurred when 
 544:FWLIB/src/stm32f4xx_pwr.c ****           waking up from Stop mode.
 545:FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 546:FWLIB/src/stm32f4xx_pwr.c ****   * @{
 547:FWLIB/src/stm32f4xx_pwr.c ****   */
 548:FWLIB/src/stm32f4xx_pwr.c **** 
 549:FWLIB/src/stm32f4xx_pwr.c **** /**
 550:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enables or disables the Flash Power Down in STOP mode.
 551:FWLIB/src/stm32f4xx_pwr.c ****   * @param  NewState: new state of the Flash power mode.
 552:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be: ENABLE or DISABLE.
 553:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 554:FWLIB/src/stm32f4xx_pwr.c ****   */
 555:FWLIB/src/stm32f4xx_pwr.c **** void PWR_FlashPowerDownCmd(FunctionalState NewState)
 556:FWLIB/src/stm32f4xx_pwr.c **** {
 403              		.loc 1 556 0
 404              		.cfi_startproc
 405              		@ args = 0, pretend = 0, frame = 0
 406              		@ frame_needed = 0, uses_anonymous_args = 0
 407              		@ link register save eliminated.
 408              	.LVL19:
 557:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 558:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_FUNCTIONAL_STATE(NewState));
 559:FWLIB/src/stm32f4xx_pwr.c **** 
 560:FWLIB/src/stm32f4xx_pwr.c ****   *(__IO uint32_t *) CR_FPDS_BB = (uint32_t)NewState;
 409              		.loc 1 560 0
 410 0000 014B     		ldr	r3, .L46
 411 0002 1860     		str	r0, [r3]
 412 0004 7047     		bx	lr
 413              	.L47:
 414 0006 00BF     		.align	2
 415              	.L46:
 416 0008 24000E42 		.word	1108213796
 417              		.cfi_endproc
 418              	.LFE124:
 420              		.section	.text.PWR_EnterSTOPMode,"ax",%progbits
 421              		.align	1
 422              		.global	PWR_EnterSTOPMode
 423              		.syntax unified
 424              		.thumb
 425              		.thumb_func
 426              		.fpu softvfp
 428              	PWR_EnterSTOPMode:
 429              	.LFB125:
 561:FWLIB/src/stm32f4xx_pwr.c **** }
 562:FWLIB/src/stm32f4xx_pwr.c **** 
 563:FWLIB/src/stm32f4xx_pwr.c **** /**
 564:FWLIB/src/stm32f4xx_pwr.c ****   * @}
ARM GAS  /tmp/cc74YnhY.s 			page 18


 565:FWLIB/src/stm32f4xx_pwr.c ****   */
 566:FWLIB/src/stm32f4xx_pwr.c **** 
 567:FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group6 Low Power modes configuration functions
 568:FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   Low Power modes configuration functions 
 569:FWLIB/src/stm32f4xx_pwr.c ****  *
 570:FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 571:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 572:FWLIB/src/stm32f4xx_pwr.c ****               ##### Low Power modes configuration functions #####
 573:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 574:FWLIB/src/stm32f4xx_pwr.c ****     [..]
 575:FWLIB/src/stm32f4xx_pwr.c ****       The devices feature 3 low-power modes:
 576:FWLIB/src/stm32f4xx_pwr.c ****       (+) Sleep mode: Cortex-M4 core stopped, peripherals kept running.
 577:FWLIB/src/stm32f4xx_pwr.c ****       (+) Stop mode: all clocks are stopped, regulator running, regulator 
 578:FWLIB/src/stm32f4xx_pwr.c ****           in low power mode
 579:FWLIB/src/stm32f4xx_pwr.c ****       (+) Standby mode: 1.2V domain powered off.
 580:FWLIB/src/stm32f4xx_pwr.c ****    
 581:FWLIB/src/stm32f4xx_pwr.c ****    *** Sleep mode ***
 582:FWLIB/src/stm32f4xx_pwr.c ****    ==================
 583:FWLIB/src/stm32f4xx_pwr.c ****     [..]
 584:FWLIB/src/stm32f4xx_pwr.c ****       (+) Entry:
 585:FWLIB/src/stm32f4xx_pwr.c ****         (++) The Sleep mode is entered by using the __WFI() or __WFE() functions.
 586:FWLIB/src/stm32f4xx_pwr.c ****       (+) Exit:
 587:FWLIB/src/stm32f4xx_pwr.c ****         (++) Any peripheral interrupt acknowledged by the nested vectored interrupt 
 588:FWLIB/src/stm32f4xx_pwr.c ****              controller (NVIC) can wake up the device from Sleep mode.
 589:FWLIB/src/stm32f4xx_pwr.c **** 
 590:FWLIB/src/stm32f4xx_pwr.c ****    *** Stop mode ***
 591:FWLIB/src/stm32f4xx_pwr.c ****    =================
 592:FWLIB/src/stm32f4xx_pwr.c ****     [..]
 593:FWLIB/src/stm32f4xx_pwr.c ****       In Stop mode, all clocks in the 1.2V domain are stopped, the PLL, the HSI,
 594:FWLIB/src/stm32f4xx_pwr.c ****       and the HSE RC oscillators are disabled. Internal SRAM and register contents 
 595:FWLIB/src/stm32f4xx_pwr.c ****       are preserved.
 596:FWLIB/src/stm32f4xx_pwr.c ****       The voltage regulator can be configured either in normal or low-power mode.
 597:FWLIB/src/stm32f4xx_pwr.c ****       To minimize the consumption In Stop mode, FLASH can be powered off before 
 598:FWLIB/src/stm32f4xx_pwr.c ****       entering the Stop mode. It can be switched on again by software after exiting 
 599:FWLIB/src/stm32f4xx_pwr.c ****       the Stop mode using the PWR_FlashPowerDownCmd() function. 
 600:FWLIB/src/stm32f4xx_pwr.c ****    
 601:FWLIB/src/stm32f4xx_pwr.c ****       (+) Entry:
 602:FWLIB/src/stm32f4xx_pwr.c ****         (++) The Stop mode is entered using the PWR_EnterSTOPMode(PWR_MainRegulator_ON) 
 603:FWLIB/src/stm32f4xx_pwr.c ****              function with:
 604:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Main regulator ON.
 605:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Low Power regulator ON.
 606:FWLIB/src/stm32f4xx_pwr.c ****       (+) Exit:
 607:FWLIB/src/stm32f4xx_pwr.c ****         (++) Any EXTI Line (Internal or External) configured in Interrupt/Event mode.
 608:FWLIB/src/stm32f4xx_pwr.c ****       
 609:FWLIB/src/stm32f4xx_pwr.c ****    *** Standby mode ***
 610:FWLIB/src/stm32f4xx_pwr.c ****    ====================
 611:FWLIB/src/stm32f4xx_pwr.c ****     [..]
 612:FWLIB/src/stm32f4xx_pwr.c ****       The Standby mode allows to achieve the lowest power consumption. It is based 
 613:FWLIB/src/stm32f4xx_pwr.c ****       on the Cortex-M4 deepsleep mode, with the voltage regulator disabled. 
 614:FWLIB/src/stm32f4xx_pwr.c ****       The 1.2V domain is consequently powered off. The PLL, the HSI oscillator and 
 615:FWLIB/src/stm32f4xx_pwr.c ****       the HSE oscillator are also switched off. SRAM and register contents are lost 
 616:FWLIB/src/stm32f4xx_pwr.c ****       except for the RTC registers, RTC backup registers, backup SRAM and Standby 
 617:FWLIB/src/stm32f4xx_pwr.c ****       circuitry.
 618:FWLIB/src/stm32f4xx_pwr.c ****    
 619:FWLIB/src/stm32f4xx_pwr.c ****       The voltage regulator is OFF.
 620:FWLIB/src/stm32f4xx_pwr.c ****       
 621:FWLIB/src/stm32f4xx_pwr.c ****       (+) Entry:
ARM GAS  /tmp/cc74YnhY.s 			page 19


 622:FWLIB/src/stm32f4xx_pwr.c ****         (++) The Standby mode is entered using the PWR_EnterSTANDBYMode() function.
 623:FWLIB/src/stm32f4xx_pwr.c ****       (+) Exit:
 624:FWLIB/src/stm32f4xx_pwr.c ****         (++) WKUP pin rising edge, RTC alarm (Alarm A and Alarm B), RTC wakeup,
 625:FWLIB/src/stm32f4xx_pwr.c ****              tamper event, time-stamp event, external reset in NRST pin, IWDG reset.              
 626:FWLIB/src/stm32f4xx_pwr.c **** 
 627:FWLIB/src/stm32f4xx_pwr.c ****    *** Auto-wakeup (AWU) from low-power mode ***
 628:FWLIB/src/stm32f4xx_pwr.c ****    =============================================
 629:FWLIB/src/stm32f4xx_pwr.c ****     [..]
 630:FWLIB/src/stm32f4xx_pwr.c ****       The MCU can be woken up from low-power mode by an RTC Alarm event, an RTC 
 631:FWLIB/src/stm32f4xx_pwr.c ****       Wakeup event, a tamper event, a time-stamp event, or a comparator event, 
 632:FWLIB/src/stm32f4xx_pwr.c ****       without depending on an external interrupt (Auto-wakeup mode).
 633:FWLIB/src/stm32f4xx_pwr.c **** 
 634:FWLIB/src/stm32f4xx_pwr.c ****       (#) RTC auto-wakeup (AWU) from the Stop mode
 635:FWLIB/src/stm32f4xx_pwr.c ****        
 636:FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Stop mode with an RTC alarm event, it is necessary to:
 637:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the EXTI Line 17 to be sensitive to rising edges (Interrupt 
 638:FWLIB/src/stm32f4xx_pwr.c ****                 or Event modes) using the EXTI_Init() function.
 639:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
 640:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 641:FWLIB/src/stm32f4xx_pwr.c ****                 and RTC_AlarmCmd() functions.
 642:FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Stop mode with an RTC Tamper or time stamp event, it 
 643:FWLIB/src/stm32f4xx_pwr.c ****              is necessary to:
 644:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the EXTI Line 21 to be sensitive to rising edges (Interrupt 
 645:FWLIB/src/stm32f4xx_pwr.c ****                 or Event modes) using the EXTI_Init() function.
 646:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 647:FWLIB/src/stm32f4xx_pwr.c ****                 function
 648:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to detect the tamper or time stamp event using the
 649:FWLIB/src/stm32f4xx_pwr.c ****                 RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 650:FWLIB/src/stm32f4xx_pwr.c ****                 functions.
 651:FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Stop mode with an RTC WakeUp event, it is necessary to:
 652:FWLIB/src/stm32f4xx_pwr.c ****            (+++) Configure the EXTI Line 22 to be sensitive to rising edges (Interrupt 
 653:FWLIB/src/stm32f4xx_pwr.c ****                  or Event modes) using the EXTI_Init() function.
 654:FWLIB/src/stm32f4xx_pwr.c ****            (+++) Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
 655:FWLIB/src/stm32f4xx_pwr.c ****            (+++) Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig
 656:FWLIB/src/stm32f4xx_pwr.c ****                  RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
 657:FWLIB/src/stm32f4xx_pwr.c **** 
 658:FWLIB/src/stm32f4xx_pwr.c ****       (#) RTC auto-wakeup (AWU) from the Standby mode
 659:FWLIB/src/stm32f4xx_pwr.c ****    
 660:FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Standby mode with an RTC alarm event, it is necessary to:
 661:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Alarm Interrupt using the RTC_ITConfig() function
 662:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to generate the RTC alarm using the RTC_SetAlarm() 
 663:FWLIB/src/stm32f4xx_pwr.c ****                 and RTC_AlarmCmd() functions.
 664:FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Standby mode with an RTC Tamper or time stamp event, it 
 665:FWLIB/src/stm32f4xx_pwr.c ****              is necessary to:
 666:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Enable the RTC Tamper or time stamp Interrupt using the RTC_ITConfig() 
 667:FWLIB/src/stm32f4xx_pwr.c ****                 function
 668:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to detect the tamper or time stamp event using the
 669:FWLIB/src/stm32f4xx_pwr.c ****                 RTC_TimeStampConfig(), RTC_TamperTriggerConfig() and RTC_TamperCmd()
 670:FWLIB/src/stm32f4xx_pwr.c ****                 functions.
 671:FWLIB/src/stm32f4xx_pwr.c ****         (++) To wake up from the Standby mode with an RTC WakeUp event, it is necessary to:
 672:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Enable the RTC WakeUp Interrupt using the RTC_ITConfig() function
 673:FWLIB/src/stm32f4xx_pwr.c ****           (+++) Configure the RTC to generate the RTC WakeUp event using the RTC_WakeUpClockConfig(
 674:FWLIB/src/stm32f4xx_pwr.c ****                 RTC_SetWakeUpCounter() and RTC_WakeUpCmd() functions.
 675:FWLIB/src/stm32f4xx_pwr.c **** 
 676:FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 677:FWLIB/src/stm32f4xx_pwr.c ****   * @{
 678:FWLIB/src/stm32f4xx_pwr.c ****   */
ARM GAS  /tmp/cc74YnhY.s 			page 20


 679:FWLIB/src/stm32f4xx_pwr.c **** 
 680:FWLIB/src/stm32f4xx_pwr.c **** /**
 681:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enters STOP mode.
 682:FWLIB/src/stm32f4xx_pwr.c ****   *   
 683:FWLIB/src/stm32f4xx_pwr.c ****   * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
 684:FWLIB/src/stm32f4xx_pwr.c ****   * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
 685:FWLIB/src/stm32f4xx_pwr.c ****   *         the HSI RC oscillator is selected as system clock.
 686:FWLIB/src/stm32f4xx_pwr.c ****   * @note   When the voltage regulator operates in low power mode, an additional 
 687:FWLIB/src/stm32f4xx_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 688:FWLIB/src/stm32f4xx_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption 
 689:FWLIB/src/stm32f4xx_pwr.c ****   *         is higher although the startup time is reduced.
 690:FWLIB/src/stm32f4xx_pwr.c ****   *     
 691:FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_Regulator: specifies the regulator state in STOP mode.
 692:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 693:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_MainRegulator_ON: STOP mode with regulator ON
 694:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_LowPowerRegulator_ON: STOP mode with low power regulator ON
 695:FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 696:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 697:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 698:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 699:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 700:FWLIB/src/stm32f4xx_pwr.c ****   */
 701:FWLIB/src/stm32f4xx_pwr.c **** void PWR_EnterSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
 702:FWLIB/src/stm32f4xx_pwr.c **** {
 430              		.loc 1 702 0
 431              		.cfi_startproc
 432              		@ args = 0, pretend = 0, frame = 0
 433              		@ frame_needed = 0, uses_anonymous_args = 0
 434              		@ link register save eliminated.
 435              	.LVL20:
 703:FWLIB/src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 704:FWLIB/src/stm32f4xx_pwr.c ****   
 705:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 706:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR(PWR_Regulator));
 707:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 708:FWLIB/src/stm32f4xx_pwr.c ****   
 709:FWLIB/src/stm32f4xx_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 710:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 436              		.loc 1 710 0
 437 0000 0B4A     		ldr	r2, .L52
 438 0002 1368     		ldr	r3, [r2]
 439              	.LVL21:
 711:FWLIB/src/stm32f4xx_pwr.c ****   /* Clear PDDS and LPDS bits */
 712:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg &= CR_DS_MASK;
 440              		.loc 1 712 0
 441 0004 23F44063 		bic	r3, r3, #3072
 442              	.LVL22:
 443 0008 23F00303 		bic	r3, r3, #3
 444              	.LVL23:
 713:FWLIB/src/stm32f4xx_pwr.c ****   
 714:FWLIB/src/stm32f4xx_pwr.c ****   /* Set LPDS, MRLVDS and LPLVDS bits according to PWR_Regulator value */
 715:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg |= PWR_Regulator;
 445              		.loc 1 715 0
 446 000c 1843     		orrs	r0, r0, r3
 447              	.LVL24:
 716:FWLIB/src/stm32f4xx_pwr.c ****   
 717:FWLIB/src/stm32f4xx_pwr.c ****   /* Store the new value */
ARM GAS  /tmp/cc74YnhY.s 			page 21


 718:FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 448              		.loc 1 718 0
 449 000e 1060     		str	r0, [r2]
 719:FWLIB/src/stm32f4xx_pwr.c ****   
 720:FWLIB/src/stm32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 721:FWLIB/src/stm32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 450              		.loc 1 721 0
 451 0010 084A     		ldr	r2, .L52+4
 452 0012 1369     		ldr	r3, [r2, #16]
 453 0014 43F00403 		orr	r3, r3, #4
 454 0018 1361     		str	r3, [r2, #16]
 722:FWLIB/src/stm32f4xx_pwr.c ****   
 723:FWLIB/src/stm32f4xx_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 724:FWLIB/src/stm32f4xx_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 455              		.loc 1 724 0
 456 001a 0129     		cmp	r1, #1
 457 001c 06D0     		beq	.L51
 458              	.LBB12:
 459              	.LBB13:
 460              		.file 2 "CORE/core_cmInstr.h"
   1:CORE/core_cmInstr.h **** /**************************************************************************//**
   2:CORE/core_cmInstr.h ****  * @file     core_cmInstr.h
   3:CORE/core_cmInstr.h ****  * @brief    CMSIS Cortex-M Core Instruction Access Header File
   4:CORE/core_cmInstr.h ****  * @version  V3.20
   5:CORE/core_cmInstr.h ****  * @date     05. March 2013
   6:CORE/core_cmInstr.h ****  *
   7:CORE/core_cmInstr.h ****  * @note
   8:CORE/core_cmInstr.h ****  *
   9:CORE/core_cmInstr.h ****  ******************************************************************************/
  10:CORE/core_cmInstr.h **** /* Copyright (c) 2009 - 2013 ARM LIMITED
  11:CORE/core_cmInstr.h **** 
  12:CORE/core_cmInstr.h ****    All rights reserved.
  13:CORE/core_cmInstr.h ****    Redistribution and use in source and binary forms, with or without
  14:CORE/core_cmInstr.h ****    modification, are permitted provided that the following conditions are met:
  15:CORE/core_cmInstr.h ****    - Redistributions of source code must retain the above copyright
  16:CORE/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer.
  17:CORE/core_cmInstr.h ****    - Redistributions in binary form must reproduce the above copyright
  18:CORE/core_cmInstr.h ****      notice, this list of conditions and the following disclaimer in the
  19:CORE/core_cmInstr.h ****      documentation and/or other materials provided with the distribution.
  20:CORE/core_cmInstr.h ****    - Neither the name of ARM nor the names of its contributors may be used
  21:CORE/core_cmInstr.h ****      to endorse or promote products derived from this software without
  22:CORE/core_cmInstr.h ****      specific prior written permission.
  23:CORE/core_cmInstr.h ****    *
  24:CORE/core_cmInstr.h ****    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  25:CORE/core_cmInstr.h ****    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  26:CORE/core_cmInstr.h ****    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  27:CORE/core_cmInstr.h ****    ARE DISCLAIMED. IN NO EVENT SHALL COPYRIGHT HOLDERS AND CONTRIBUTORS BE
  28:CORE/core_cmInstr.h ****    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  29:CORE/core_cmInstr.h ****    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  30:CORE/core_cmInstr.h ****    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  31:CORE/core_cmInstr.h ****    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  32:CORE/core_cmInstr.h ****    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  33:CORE/core_cmInstr.h ****    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  34:CORE/core_cmInstr.h ****    POSSIBILITY OF SUCH DAMAGE.
  35:CORE/core_cmInstr.h ****    ---------------------------------------------------------------------------*/
  36:CORE/core_cmInstr.h **** 
  37:CORE/core_cmInstr.h **** 
ARM GAS  /tmp/cc74YnhY.s 			page 22


  38:CORE/core_cmInstr.h **** #ifndef __CORE_CMINSTR_H
  39:CORE/core_cmInstr.h **** #define __CORE_CMINSTR_H
  40:CORE/core_cmInstr.h **** 
  41:CORE/core_cmInstr.h **** 
  42:CORE/core_cmInstr.h **** /* ##########################  Core Instruction Access  ######################### */
  43:CORE/core_cmInstr.h **** /** \defgroup CMSIS_Core_InstructionInterface CMSIS Core Instruction Interface
  44:CORE/core_cmInstr.h ****   Access to dedicated instructions
  45:CORE/core_cmInstr.h ****   @{
  46:CORE/core_cmInstr.h **** */
  47:CORE/core_cmInstr.h **** 
  48:CORE/core_cmInstr.h **** #if   defined ( __CC_ARM ) /*------------------RealView Compiler -----------------*/
  49:CORE/core_cmInstr.h **** /* ARM armcc specific functions */
  50:CORE/core_cmInstr.h **** 
  51:CORE/core_cmInstr.h **** #if (__ARMCC_VERSION < 400677)
  52:CORE/core_cmInstr.h ****   #error "Please use ARM Compiler Toolchain V4.0.677 or later!"
  53:CORE/core_cmInstr.h **** #endif
  54:CORE/core_cmInstr.h **** 
  55:CORE/core_cmInstr.h **** 
  56:CORE/core_cmInstr.h **** /** \brief  No Operation
  57:CORE/core_cmInstr.h **** 
  58:CORE/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
  59:CORE/core_cmInstr.h ****  */
  60:CORE/core_cmInstr.h **** #define __NOP                             __nop
  61:CORE/core_cmInstr.h **** 
  62:CORE/core_cmInstr.h **** 
  63:CORE/core_cmInstr.h **** /** \brief  Wait For Interrupt
  64:CORE/core_cmInstr.h **** 
  65:CORE/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
  66:CORE/core_cmInstr.h ****     until one of a number of events occurs.
  67:CORE/core_cmInstr.h ****  */
  68:CORE/core_cmInstr.h **** #define __WFI                             __wfi
  69:CORE/core_cmInstr.h **** 
  70:CORE/core_cmInstr.h **** 
  71:CORE/core_cmInstr.h **** /** \brief  Wait For Event
  72:CORE/core_cmInstr.h **** 
  73:CORE/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
  74:CORE/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
  75:CORE/core_cmInstr.h ****  */
  76:CORE/core_cmInstr.h **** #define __WFE                             __wfe
  77:CORE/core_cmInstr.h **** 
  78:CORE/core_cmInstr.h **** 
  79:CORE/core_cmInstr.h **** /** \brief  Send Event
  80:CORE/core_cmInstr.h **** 
  81:CORE/core_cmInstr.h ****     Send Event is a hint instruction. It causes an event to be signaled to the CPU.
  82:CORE/core_cmInstr.h ****  */
  83:CORE/core_cmInstr.h **** #define __SEV                             __sev
  84:CORE/core_cmInstr.h **** 
  85:CORE/core_cmInstr.h **** 
  86:CORE/core_cmInstr.h **** /** \brief  Instruction Synchronization Barrier
  87:CORE/core_cmInstr.h **** 
  88:CORE/core_cmInstr.h ****     Instruction Synchronization Barrier flushes the pipeline in the processor,
  89:CORE/core_cmInstr.h ****     so that all instructions following the ISB are fetched from cache or
  90:CORE/core_cmInstr.h ****     memory, after the instruction has been completed.
  91:CORE/core_cmInstr.h ****  */
  92:CORE/core_cmInstr.h **** #define __ISB()                           __isb(0xF)
  93:CORE/core_cmInstr.h **** 
  94:CORE/core_cmInstr.h **** 
ARM GAS  /tmp/cc74YnhY.s 			page 23


  95:CORE/core_cmInstr.h **** /** \brief  Data Synchronization Barrier
  96:CORE/core_cmInstr.h **** 
  97:CORE/core_cmInstr.h ****     This function acts as a special kind of Data Memory Barrier.
  98:CORE/core_cmInstr.h ****     It completes when all explicit memory accesses before this instruction complete.
  99:CORE/core_cmInstr.h ****  */
 100:CORE/core_cmInstr.h **** #define __DSB()                           __dsb(0xF)
 101:CORE/core_cmInstr.h **** 
 102:CORE/core_cmInstr.h **** 
 103:CORE/core_cmInstr.h **** /** \brief  Data Memory Barrier
 104:CORE/core_cmInstr.h **** 
 105:CORE/core_cmInstr.h ****     This function ensures the apparent order of the explicit memory operations before
 106:CORE/core_cmInstr.h ****     and after the instruction, without ensuring their completion.
 107:CORE/core_cmInstr.h ****  */
 108:CORE/core_cmInstr.h **** #define __DMB()                           __dmb(0xF)
 109:CORE/core_cmInstr.h **** 
 110:CORE/core_cmInstr.h **** 
 111:CORE/core_cmInstr.h **** /** \brief  Reverse byte order (32 bit)
 112:CORE/core_cmInstr.h **** 
 113:CORE/core_cmInstr.h ****     This function reverses the byte order in integer value.
 114:CORE/core_cmInstr.h **** 
 115:CORE/core_cmInstr.h ****     \param [in]    value  Value to reverse
 116:CORE/core_cmInstr.h ****     \return               Reversed value
 117:CORE/core_cmInstr.h ****  */
 118:CORE/core_cmInstr.h **** #define __REV                             __rev
 119:CORE/core_cmInstr.h **** 
 120:CORE/core_cmInstr.h **** 
 121:CORE/core_cmInstr.h **** /** \brief  Reverse byte order (16 bit)
 122:CORE/core_cmInstr.h **** 
 123:CORE/core_cmInstr.h ****     This function reverses the byte order in two unsigned short values.
 124:CORE/core_cmInstr.h **** 
 125:CORE/core_cmInstr.h ****     \param [in]    value  Value to reverse
 126:CORE/core_cmInstr.h ****     \return               Reversed value
 127:CORE/core_cmInstr.h ****  */
 128:CORE/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 129:CORE/core_cmInstr.h **** __attribute__((section(".rev16_text"))) __STATIC_INLINE __ASM uint32_t __REV16(uint32_t value)
 130:CORE/core_cmInstr.h **** {
 131:CORE/core_cmInstr.h ****   rev16 r0, r0
 132:CORE/core_cmInstr.h ****   bx lr
 133:CORE/core_cmInstr.h **** }
 134:CORE/core_cmInstr.h **** #endif
 135:CORE/core_cmInstr.h **** 
 136:CORE/core_cmInstr.h **** /** \brief  Reverse byte order in signed short value
 137:CORE/core_cmInstr.h **** 
 138:CORE/core_cmInstr.h ****     This function reverses the byte order in a signed short value with sign extension to integer.
 139:CORE/core_cmInstr.h **** 
 140:CORE/core_cmInstr.h ****     \param [in]    value  Value to reverse
 141:CORE/core_cmInstr.h ****     \return               Reversed value
 142:CORE/core_cmInstr.h ****  */
 143:CORE/core_cmInstr.h **** #ifndef __NO_EMBEDDED_ASM
 144:CORE/core_cmInstr.h **** __attribute__((section(".revsh_text"))) __STATIC_INLINE __ASM int32_t __REVSH(int32_t value)
 145:CORE/core_cmInstr.h **** {
 146:CORE/core_cmInstr.h ****   revsh r0, r0
 147:CORE/core_cmInstr.h ****   bx lr
 148:CORE/core_cmInstr.h **** }
 149:CORE/core_cmInstr.h **** #endif
 150:CORE/core_cmInstr.h **** 
 151:CORE/core_cmInstr.h **** 
ARM GAS  /tmp/cc74YnhY.s 			page 24


 152:CORE/core_cmInstr.h **** /** \brief  Rotate Right in unsigned value (32 bit)
 153:CORE/core_cmInstr.h **** 
 154:CORE/core_cmInstr.h ****     This function Rotate Right (immediate) provides the value of the contents of a register rotated
 155:CORE/core_cmInstr.h **** 
 156:CORE/core_cmInstr.h ****     \param [in]    value  Value to rotate
 157:CORE/core_cmInstr.h ****     \param [in]    value  Number of Bits to rotate
 158:CORE/core_cmInstr.h ****     \return               Rotated value
 159:CORE/core_cmInstr.h ****  */
 160:CORE/core_cmInstr.h **** #define __ROR                             __ror
 161:CORE/core_cmInstr.h **** 
 162:CORE/core_cmInstr.h **** 
 163:CORE/core_cmInstr.h **** /** \brief  Breakpoint
 164:CORE/core_cmInstr.h **** 
 165:CORE/core_cmInstr.h ****     This function causes the processor to enter Debug state.
 166:CORE/core_cmInstr.h ****     Debug tools can use this to investigate system state when the instruction at a particular addre
 167:CORE/core_cmInstr.h **** 
 168:CORE/core_cmInstr.h ****     \param [in]    value  is ignored by the processor.
 169:CORE/core_cmInstr.h ****                    If required, a debugger can use it to store additional information about the bre
 170:CORE/core_cmInstr.h ****  */
 171:CORE/core_cmInstr.h **** #define __BKPT(value)                       __breakpoint(value)
 172:CORE/core_cmInstr.h **** 
 173:CORE/core_cmInstr.h **** 
 174:CORE/core_cmInstr.h **** #if       (__CORTEX_M >= 0x03)
 175:CORE/core_cmInstr.h **** 
 176:CORE/core_cmInstr.h **** /** \brief  Reverse bit order of value
 177:CORE/core_cmInstr.h **** 
 178:CORE/core_cmInstr.h ****     This function reverses the bit order of the given value.
 179:CORE/core_cmInstr.h **** 
 180:CORE/core_cmInstr.h ****     \param [in]    value  Value to reverse
 181:CORE/core_cmInstr.h ****     \return               Reversed value
 182:CORE/core_cmInstr.h ****  */
 183:CORE/core_cmInstr.h **** #define __RBIT                            __rbit
 184:CORE/core_cmInstr.h **** 
 185:CORE/core_cmInstr.h **** 
 186:CORE/core_cmInstr.h **** /** \brief  LDR Exclusive (8 bit)
 187:CORE/core_cmInstr.h **** 
 188:CORE/core_cmInstr.h ****     This function performs a exclusive LDR command for 8 bit value.
 189:CORE/core_cmInstr.h **** 
 190:CORE/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 191:CORE/core_cmInstr.h ****     \return             value of type uint8_t at (*ptr)
 192:CORE/core_cmInstr.h ****  */
 193:CORE/core_cmInstr.h **** #define __LDREXB(ptr)                     ((uint8_t ) __ldrex(ptr))
 194:CORE/core_cmInstr.h **** 
 195:CORE/core_cmInstr.h **** 
 196:CORE/core_cmInstr.h **** /** \brief  LDR Exclusive (16 bit)
 197:CORE/core_cmInstr.h **** 
 198:CORE/core_cmInstr.h ****     This function performs a exclusive LDR command for 16 bit values.
 199:CORE/core_cmInstr.h **** 
 200:CORE/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 201:CORE/core_cmInstr.h ****     \return        value of type uint16_t at (*ptr)
 202:CORE/core_cmInstr.h ****  */
 203:CORE/core_cmInstr.h **** #define __LDREXH(ptr)                     ((uint16_t) __ldrex(ptr))
 204:CORE/core_cmInstr.h **** 
 205:CORE/core_cmInstr.h **** 
 206:CORE/core_cmInstr.h **** /** \brief  LDR Exclusive (32 bit)
 207:CORE/core_cmInstr.h **** 
 208:CORE/core_cmInstr.h ****     This function performs a exclusive LDR command for 32 bit values.
ARM GAS  /tmp/cc74YnhY.s 			page 25


 209:CORE/core_cmInstr.h **** 
 210:CORE/core_cmInstr.h ****     \param [in]    ptr  Pointer to data
 211:CORE/core_cmInstr.h ****     \return        value of type uint32_t at (*ptr)
 212:CORE/core_cmInstr.h ****  */
 213:CORE/core_cmInstr.h **** #define __LDREXW(ptr)                     ((uint32_t ) __ldrex(ptr))
 214:CORE/core_cmInstr.h **** 
 215:CORE/core_cmInstr.h **** 
 216:CORE/core_cmInstr.h **** /** \brief  STR Exclusive (8 bit)
 217:CORE/core_cmInstr.h **** 
 218:CORE/core_cmInstr.h ****     This function performs a exclusive STR command for 8 bit values.
 219:CORE/core_cmInstr.h **** 
 220:CORE/core_cmInstr.h ****     \param [in]  value  Value to store
 221:CORE/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 222:CORE/core_cmInstr.h ****     \return          0  Function succeeded
 223:CORE/core_cmInstr.h ****     \return          1  Function failed
 224:CORE/core_cmInstr.h ****  */
 225:CORE/core_cmInstr.h **** #define __STREXB(value, ptr)              __strex(value, ptr)
 226:CORE/core_cmInstr.h **** 
 227:CORE/core_cmInstr.h **** 
 228:CORE/core_cmInstr.h **** /** \brief  STR Exclusive (16 bit)
 229:CORE/core_cmInstr.h **** 
 230:CORE/core_cmInstr.h ****     This function performs a exclusive STR command for 16 bit values.
 231:CORE/core_cmInstr.h **** 
 232:CORE/core_cmInstr.h ****     \param [in]  value  Value to store
 233:CORE/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 234:CORE/core_cmInstr.h ****     \return          0  Function succeeded
 235:CORE/core_cmInstr.h ****     \return          1  Function failed
 236:CORE/core_cmInstr.h ****  */
 237:CORE/core_cmInstr.h **** #define __STREXH(value, ptr)              __strex(value, ptr)
 238:CORE/core_cmInstr.h **** 
 239:CORE/core_cmInstr.h **** 
 240:CORE/core_cmInstr.h **** /** \brief  STR Exclusive (32 bit)
 241:CORE/core_cmInstr.h **** 
 242:CORE/core_cmInstr.h ****     This function performs a exclusive STR command for 32 bit values.
 243:CORE/core_cmInstr.h **** 
 244:CORE/core_cmInstr.h ****     \param [in]  value  Value to store
 245:CORE/core_cmInstr.h ****     \param [in]    ptr  Pointer to location
 246:CORE/core_cmInstr.h ****     \return          0  Function succeeded
 247:CORE/core_cmInstr.h ****     \return          1  Function failed
 248:CORE/core_cmInstr.h ****  */
 249:CORE/core_cmInstr.h **** #define __STREXW(value, ptr)              __strex(value, ptr)
 250:CORE/core_cmInstr.h **** 
 251:CORE/core_cmInstr.h **** 
 252:CORE/core_cmInstr.h **** /** \brief  Remove the exclusive lock
 253:CORE/core_cmInstr.h **** 
 254:CORE/core_cmInstr.h ****     This function removes the exclusive lock which is created by LDREX.
 255:CORE/core_cmInstr.h **** 
 256:CORE/core_cmInstr.h ****  */
 257:CORE/core_cmInstr.h **** #define __CLREX                           __clrex
 258:CORE/core_cmInstr.h **** 
 259:CORE/core_cmInstr.h **** 
 260:CORE/core_cmInstr.h **** /** \brief  Signed Saturate
 261:CORE/core_cmInstr.h **** 
 262:CORE/core_cmInstr.h ****     This function saturates a signed value.
 263:CORE/core_cmInstr.h **** 
 264:CORE/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 265:CORE/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (1..32)
ARM GAS  /tmp/cc74YnhY.s 			page 26


 266:CORE/core_cmInstr.h ****     \return             Saturated value
 267:CORE/core_cmInstr.h ****  */
 268:CORE/core_cmInstr.h **** #define __SSAT                            __ssat
 269:CORE/core_cmInstr.h **** 
 270:CORE/core_cmInstr.h **** 
 271:CORE/core_cmInstr.h **** /** \brief  Unsigned Saturate
 272:CORE/core_cmInstr.h **** 
 273:CORE/core_cmInstr.h ****     This function saturates an unsigned value.
 274:CORE/core_cmInstr.h **** 
 275:CORE/core_cmInstr.h ****     \param [in]  value  Value to be saturated
 276:CORE/core_cmInstr.h ****     \param [in]    sat  Bit position to saturate to (0..31)
 277:CORE/core_cmInstr.h ****     \return             Saturated value
 278:CORE/core_cmInstr.h ****  */
 279:CORE/core_cmInstr.h **** #define __USAT                            __usat
 280:CORE/core_cmInstr.h **** 
 281:CORE/core_cmInstr.h **** 
 282:CORE/core_cmInstr.h **** /** \brief  Count leading zeros
 283:CORE/core_cmInstr.h **** 
 284:CORE/core_cmInstr.h ****     This function counts the number of leading zeros of a data value.
 285:CORE/core_cmInstr.h **** 
 286:CORE/core_cmInstr.h ****     \param [in]  value  Value to count the leading zeros
 287:CORE/core_cmInstr.h ****     \return             number of leading zeros in value
 288:CORE/core_cmInstr.h ****  */
 289:CORE/core_cmInstr.h **** #define __CLZ                             __clz
 290:CORE/core_cmInstr.h **** 
 291:CORE/core_cmInstr.h **** #endif /* (__CORTEX_M >= 0x03) */
 292:CORE/core_cmInstr.h **** 
 293:CORE/core_cmInstr.h **** 
 294:CORE/core_cmInstr.h **** 
 295:CORE/core_cmInstr.h **** #elif defined ( __ICCARM__ ) /*------------------ ICC Compiler -------------------*/
 296:CORE/core_cmInstr.h **** /* IAR iccarm specific functions */
 297:CORE/core_cmInstr.h **** 
 298:CORE/core_cmInstr.h **** #include <cmsis_iar.h>
 299:CORE/core_cmInstr.h **** 
 300:CORE/core_cmInstr.h **** 
 301:CORE/core_cmInstr.h **** #elif defined ( __TMS470__ ) /*---------------- TI CCS Compiler ------------------*/
 302:CORE/core_cmInstr.h **** /* TI CCS specific functions */
 303:CORE/core_cmInstr.h **** 
 304:CORE/core_cmInstr.h **** #include <cmsis_ccs.h>
 305:CORE/core_cmInstr.h **** 
 306:CORE/core_cmInstr.h **** 
 307:CORE/core_cmInstr.h **** #elif defined ( __GNUC__ ) /*------------------ GNU Compiler ---------------------*/
 308:CORE/core_cmInstr.h **** /* GNU gcc specific functions */
 309:CORE/core_cmInstr.h **** 
 310:CORE/core_cmInstr.h **** /* Define macros for porting to both thumb1 and thumb2.
 311:CORE/core_cmInstr.h ****  * For thumb1, use low register (r0-r7), specified by constrant "l"
 312:CORE/core_cmInstr.h ****  * Otherwise, use general registers, specified by constrant "r" */
 313:CORE/core_cmInstr.h **** #if defined (__thumb__) && !defined (__thumb2__)
 314:CORE/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=l" (r)
 315:CORE/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "l" (r)
 316:CORE/core_cmInstr.h **** #else
 317:CORE/core_cmInstr.h **** #define __CMSIS_GCC_OUT_REG(r) "=r" (r)
 318:CORE/core_cmInstr.h **** #define __CMSIS_GCC_USE_REG(r) "r" (r)
 319:CORE/core_cmInstr.h **** #endif
 320:CORE/core_cmInstr.h **** 
 321:CORE/core_cmInstr.h **** /** \brief  No Operation
 322:CORE/core_cmInstr.h **** 
ARM GAS  /tmp/cc74YnhY.s 			page 27


 323:CORE/core_cmInstr.h ****     No Operation does nothing. This instruction can be used for code alignment purposes.
 324:CORE/core_cmInstr.h ****  */
 325:CORE/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __NOP(void)
 326:CORE/core_cmInstr.h **** {
 327:CORE/core_cmInstr.h ****   __ASM volatile ("nop");
 328:CORE/core_cmInstr.h **** }
 329:CORE/core_cmInstr.h **** 
 330:CORE/core_cmInstr.h **** 
 331:CORE/core_cmInstr.h **** /** \brief  Wait For Interrupt
 332:CORE/core_cmInstr.h **** 
 333:CORE/core_cmInstr.h ****     Wait For Interrupt is a hint instruction that suspends execution
 334:CORE/core_cmInstr.h ****     until one of a number of events occurs.
 335:CORE/core_cmInstr.h ****  */
 336:CORE/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFI(void)
 337:CORE/core_cmInstr.h **** {
 338:CORE/core_cmInstr.h ****   __ASM volatile ("wfi");
 339:CORE/core_cmInstr.h **** }
 340:CORE/core_cmInstr.h **** 
 341:CORE/core_cmInstr.h **** 
 342:CORE/core_cmInstr.h **** /** \brief  Wait For Event
 343:CORE/core_cmInstr.h **** 
 344:CORE/core_cmInstr.h ****     Wait For Event is a hint instruction that permits the processor to enter
 345:CORE/core_cmInstr.h ****     a low-power state until one of a number of events occurs.
 346:CORE/core_cmInstr.h ****  */
 347:CORE/core_cmInstr.h **** __attribute__( ( always_inline ) ) __STATIC_INLINE void __WFE(void)
 348:CORE/core_cmInstr.h **** {
 349:CORE/core_cmInstr.h ****   __ASM volatile ("wfe");
 461              		.loc 2 349 0
 462              		.syntax unified
 463              	@ 349 "CORE/core_cmInstr.h" 1
 464 001e 20BF     		wfe
 465              	@ 0 "" 2
 466              		.thumb
 467              		.syntax unified
 468              	.L50:
 469              	.LBE13:
 470              	.LBE12:
 725:FWLIB/src/stm32f4xx_pwr.c ****   {   
 726:FWLIB/src/stm32f4xx_pwr.c ****     /* Request Wait For Interrupt */
 727:FWLIB/src/stm32f4xx_pwr.c ****     __WFI();
 728:FWLIB/src/stm32f4xx_pwr.c ****   }
 729:FWLIB/src/stm32f4xx_pwr.c ****   else
 730:FWLIB/src/stm32f4xx_pwr.c ****   {
 731:FWLIB/src/stm32f4xx_pwr.c ****     /* Request Wait For Event */
 732:FWLIB/src/stm32f4xx_pwr.c ****     __WFE();
 733:FWLIB/src/stm32f4xx_pwr.c ****   }
 734:FWLIB/src/stm32f4xx_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 735:FWLIB/src/stm32f4xx_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 471              		.loc 1 735 0
 472 0020 044A     		ldr	r2, .L52+4
 473 0022 1369     		ldr	r3, [r2, #16]
 474 0024 23F00403 		bic	r3, r3, #4
 475 0028 1361     		str	r3, [r2, #16]
 476 002a 7047     		bx	lr
 477              	.L51:
 478              	.LBB14:
 479              	.LBB15:
ARM GAS  /tmp/cc74YnhY.s 			page 28


 338:CORE/core_cmInstr.h **** }
 480              		.loc 2 338 0
 481              		.syntax unified
 482              	@ 338 "CORE/core_cmInstr.h" 1
 483 002c 30BF     		wfi
 484              	@ 0 "" 2
 485              		.thumb
 486              		.syntax unified
 487 002e F7E7     		b	.L50
 488              	.L53:
 489              		.align	2
 490              	.L52:
 491 0030 00700040 		.word	1073770496
 492 0034 00ED00E0 		.word	-536810240
 493              	.LBE15:
 494              	.LBE14:
 495              		.cfi_endproc
 496              	.LFE125:
 498              		.section	.text.PWR_EnterUnderDriveSTOPMode,"ax",%progbits
 499              		.align	1
 500              		.global	PWR_EnterUnderDriveSTOPMode
 501              		.syntax unified
 502              		.thumb
 503              		.thumb_func
 504              		.fpu softvfp
 506              	PWR_EnterUnderDriveSTOPMode:
 507              	.LFB126:
 736:FWLIB/src/stm32f4xx_pwr.c **** }
 737:FWLIB/src/stm32f4xx_pwr.c **** 
 738:FWLIB/src/stm32f4xx_pwr.c **** /**
 739:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enters in Under-Drive STOP mode.
 740:FWLIB/src/stm32f4xx_pwr.c ****   *  
 741:FWLIB/src/stm32f4xx_pwr.c ****   * @note   This mode is only available for STM32F42xxx/STM3243xxx devices. 
 742:FWLIB/src/stm32f4xx_pwr.c ****   * 
 743:FWLIB/src/stm32f4xx_pwr.c ****   * @note    This mode can be selected only when the Under-Drive is already active 
 744:FWLIB/src/stm32f4xx_pwr.c ****   *         
 745:FWLIB/src/stm32f4xx_pwr.c ****   * @note   In Stop mode, all I/O pins keep the same state as in Run mode.
 746:FWLIB/src/stm32f4xx_pwr.c ****   * @note   When exiting Stop mode by issuing an interrupt or a wakeup event, 
 747:FWLIB/src/stm32f4xx_pwr.c ****   *         the HSI RC oscillator is selected as system clock.
 748:FWLIB/src/stm32f4xx_pwr.c ****   * @note   When the voltage regulator operates in low power mode, an additional 
 749:FWLIB/src/stm32f4xx_pwr.c ****   *         startup delay is incurred when waking up from Stop mode. 
 750:FWLIB/src/stm32f4xx_pwr.c ****   *         By keeping the internal regulator ON during Stop mode, the consumption 
 751:FWLIB/src/stm32f4xx_pwr.c ****   *         is higher although the startup time is reduced.
 752:FWLIB/src/stm32f4xx_pwr.c ****   *     
 753:FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_Regulator: specifies the regulator state in STOP mode.
 754:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 755:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_MainRegulator_UnderDrive_ON:  Main Regulator in under-drive mode 
 756:FWLIB/src/stm32f4xx_pwr.c ****   *                 and Flash memory in power-down when the device is in Stop under-drive mode
 757:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_LowPowerRegulator_UnderDrive_ON:  Low Power Regulator in under-drive mode 
 758:FWLIB/src/stm32f4xx_pwr.c ****   *                and Flash memory in power-down when the device is in Stop under-drive mode
 759:FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_STOPEntry: specifies if STOP mode in entered with WFI or WFE instruction.
 760:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 761:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFI: enter STOP mode with WFI instruction
 762:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_STOPEntry_WFE: enter STOP mode with WFE instruction
 763:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 764:FWLIB/src/stm32f4xx_pwr.c ****   */
 765:FWLIB/src/stm32f4xx_pwr.c **** void PWR_EnterUnderDriveSTOPMode(uint32_t PWR_Regulator, uint8_t PWR_STOPEntry)
ARM GAS  /tmp/cc74YnhY.s 			page 29


 766:FWLIB/src/stm32f4xx_pwr.c **** {
 508              		.loc 1 766 0
 509              		.cfi_startproc
 510              		@ args = 0, pretend = 0, frame = 0
 511              		@ frame_needed = 0, uses_anonymous_args = 0
 512              		@ link register save eliminated.
 513              	.LVL25:
 767:FWLIB/src/stm32f4xx_pwr.c ****   uint32_t tmpreg = 0;
 768:FWLIB/src/stm32f4xx_pwr.c ****   
 769:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 770:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_REGULATOR_UNDERDRIVE(PWR_Regulator));
 771:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_STOP_ENTRY(PWR_STOPEntry));
 772:FWLIB/src/stm32f4xx_pwr.c ****   
 773:FWLIB/src/stm32f4xx_pwr.c ****   /* Select the regulator state in STOP mode ---------------------------------*/
 774:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg = PWR->CR;
 514              		.loc 1 774 0
 515 0000 0B4A     		ldr	r2, .L58
 516 0002 1368     		ldr	r3, [r2]
 517              	.LVL26:
 775:FWLIB/src/stm32f4xx_pwr.c ****   /* Clear PDDS and LPDS bits */
 776:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg &= CR_DS_MASK;
 518              		.loc 1 776 0
 519 0004 23F44063 		bic	r3, r3, #3072
 520              	.LVL27:
 521 0008 23F00303 		bic	r3, r3, #3
 522              	.LVL28:
 777:FWLIB/src/stm32f4xx_pwr.c ****   
 778:FWLIB/src/stm32f4xx_pwr.c ****   /* Set LPDS, MRLUDS and LPLUDS bits according to PWR_Regulator value */
 779:FWLIB/src/stm32f4xx_pwr.c ****   tmpreg |= PWR_Regulator;
 523              		.loc 1 779 0
 524 000c 1843     		orrs	r0, r0, r3
 525              	.LVL29:
 780:FWLIB/src/stm32f4xx_pwr.c ****   
 781:FWLIB/src/stm32f4xx_pwr.c ****   /* Store the new value */
 782:FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR = tmpreg;
 526              		.loc 1 782 0
 527 000e 1060     		str	r0, [r2]
 783:FWLIB/src/stm32f4xx_pwr.c ****   
 784:FWLIB/src/stm32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 785:FWLIB/src/stm32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 528              		.loc 1 785 0
 529 0010 084A     		ldr	r2, .L58+4
 530 0012 1369     		ldr	r3, [r2, #16]
 531 0014 43F00403 		orr	r3, r3, #4
 532 0018 1361     		str	r3, [r2, #16]
 786:FWLIB/src/stm32f4xx_pwr.c ****   
 787:FWLIB/src/stm32f4xx_pwr.c ****   /* Select STOP mode entry --------------------------------------------------*/
 788:FWLIB/src/stm32f4xx_pwr.c ****   if(PWR_STOPEntry == PWR_STOPEntry_WFI)
 533              		.loc 1 788 0
 534 001a 0129     		cmp	r1, #1
 535 001c 06D0     		beq	.L57
 536              	.LBB16:
 537              	.LBB17:
 538              		.loc 2 349 0
 539              		.syntax unified
 540              	@ 349 "CORE/core_cmInstr.h" 1
 541 001e 20BF     		wfe
ARM GAS  /tmp/cc74YnhY.s 			page 30


 542              	@ 0 "" 2
 543              		.thumb
 544              		.syntax unified
 545              	.L56:
 546              	.LBE17:
 547              	.LBE16:
 789:FWLIB/src/stm32f4xx_pwr.c ****   {   
 790:FWLIB/src/stm32f4xx_pwr.c ****     /* Request Wait For Interrupt */
 791:FWLIB/src/stm32f4xx_pwr.c ****     __WFI();
 792:FWLIB/src/stm32f4xx_pwr.c ****   }
 793:FWLIB/src/stm32f4xx_pwr.c ****   else
 794:FWLIB/src/stm32f4xx_pwr.c ****   {
 795:FWLIB/src/stm32f4xx_pwr.c ****     /* Request Wait For Event */
 796:FWLIB/src/stm32f4xx_pwr.c ****     __WFE();
 797:FWLIB/src/stm32f4xx_pwr.c ****   }
 798:FWLIB/src/stm32f4xx_pwr.c ****   /* Reset SLEEPDEEP bit of Cortex System Control Register */
 799:FWLIB/src/stm32f4xx_pwr.c ****   SCB->SCR &= (uint32_t)~((uint32_t)SCB_SCR_SLEEPDEEP_Msk);  
 548              		.loc 1 799 0
 549 0020 044A     		ldr	r2, .L58+4
 550 0022 1369     		ldr	r3, [r2, #16]
 551 0024 23F00403 		bic	r3, r3, #4
 552 0028 1361     		str	r3, [r2, #16]
 553 002a 7047     		bx	lr
 554              	.L57:
 555              	.LBB18:
 556              	.LBB19:
 338:CORE/core_cmInstr.h **** }
 557              		.loc 2 338 0
 558              		.syntax unified
 559              	@ 338 "CORE/core_cmInstr.h" 1
 560 002c 30BF     		wfi
 561              	@ 0 "" 2
 562              		.thumb
 563              		.syntax unified
 564 002e F7E7     		b	.L56
 565              	.L59:
 566              		.align	2
 567              	.L58:
 568 0030 00700040 		.word	1073770496
 569 0034 00ED00E0 		.word	-536810240
 570              	.LBE19:
 571              	.LBE18:
 572              		.cfi_endproc
 573              	.LFE126:
 575              		.section	.text.PWR_EnterSTANDBYMode,"ax",%progbits
 576              		.align	1
 577              		.global	PWR_EnterSTANDBYMode
 578              		.syntax unified
 579              		.thumb
 580              		.thumb_func
 581              		.fpu softvfp
 583              	PWR_EnterSTANDBYMode:
 584              	.LFB127:
 800:FWLIB/src/stm32f4xx_pwr.c **** }
 801:FWLIB/src/stm32f4xx_pwr.c **** 
 802:FWLIB/src/stm32f4xx_pwr.c **** /**
 803:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Enters STANDBY mode.
ARM GAS  /tmp/cc74YnhY.s 			page 31


 804:FWLIB/src/stm32f4xx_pwr.c ****   * @note   In Standby mode, all I/O pins are high impedance except for:
 805:FWLIB/src/stm32f4xx_pwr.c ****   *          - Reset pad (still available) 
 806:FWLIB/src/stm32f4xx_pwr.c ****   *          - RTC_AF1 pin (PC13) if configured for tamper, time-stamp, RTC 
 807:FWLIB/src/stm32f4xx_pwr.c ****   *            Alarm out, or RTC clock calibration out.
 808:FWLIB/src/stm32f4xx_pwr.c ****   *          - RTC_AF2 pin (PI8) if configured for tamper or time-stamp.  
 809:FWLIB/src/stm32f4xx_pwr.c ****   *          - WKUP pin 1 (PA0) if enabled.
 810:FWLIB/src/stm32f4xx_pwr.c ****   * @note   The Wakeup flag (WUF) need to be cleared at application level before to call this funct
 811:FWLIB/src/stm32f4xx_pwr.c ****   * @param  None
 812:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 813:FWLIB/src/stm32f4xx_pwr.c ****   */
 814:FWLIB/src/stm32f4xx_pwr.c **** void PWR_EnterSTANDBYMode(void)
 815:FWLIB/src/stm32f4xx_pwr.c **** {
 585              		.loc 1 815 0
 586              		.cfi_startproc
 587              		@ args = 0, pretend = 0, frame = 0
 588              		@ frame_needed = 0, uses_anonymous_args = 0
 589              		@ link register save eliminated.
 816:FWLIB/src/stm32f4xx_pwr.c ****   /* Select STANDBY mode */
 817:FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR |= PWR_CR_PDDS;
 590              		.loc 1 817 0
 591 0000 054A     		ldr	r2, .L61
 592 0002 1368     		ldr	r3, [r2]
 593 0004 43F00203 		orr	r3, r3, #2
 594 0008 1360     		str	r3, [r2]
 818:FWLIB/src/stm32f4xx_pwr.c ****   
 819:FWLIB/src/stm32f4xx_pwr.c ****   /* Set SLEEPDEEP bit of Cortex System Control Register */
 820:FWLIB/src/stm32f4xx_pwr.c ****   SCB->SCR |= SCB_SCR_SLEEPDEEP_Msk;
 595              		.loc 1 820 0
 596 000a 044A     		ldr	r2, .L61+4
 597 000c 1369     		ldr	r3, [r2, #16]
 598 000e 43F00403 		orr	r3, r3, #4
 599 0012 1361     		str	r3, [r2, #16]
 600              	.LBB20:
 601              	.LBB21:
 338:CORE/core_cmInstr.h **** }
 602              		.loc 2 338 0
 603              		.syntax unified
 604              	@ 338 "CORE/core_cmInstr.h" 1
 605 0014 30BF     		wfi
 606              	@ 0 "" 2
 607              		.thumb
 608              		.syntax unified
 609 0016 7047     		bx	lr
 610              	.L62:
 611              		.align	2
 612              	.L61:
 613 0018 00700040 		.word	1073770496
 614 001c 00ED00E0 		.word	-536810240
 615              	.LBE21:
 616              	.LBE20:
 617              		.cfi_endproc
 618              	.LFE127:
 620              		.section	.text.PWR_GetFlagStatus,"ax",%progbits
 621              		.align	1
 622              		.global	PWR_GetFlagStatus
 623              		.syntax unified
 624              		.thumb
ARM GAS  /tmp/cc74YnhY.s 			page 32


 625              		.thumb_func
 626              		.fpu softvfp
 628              	PWR_GetFlagStatus:
 629              	.LFB128:
 821:FWLIB/src/stm32f4xx_pwr.c ****   
 822:FWLIB/src/stm32f4xx_pwr.c ****   /* This option is used to ensure that store operations are completed */
 823:FWLIB/src/stm32f4xx_pwr.c **** #if defined ( __CC_ARM   )
 824:FWLIB/src/stm32f4xx_pwr.c ****   __force_stores();
 825:FWLIB/src/stm32f4xx_pwr.c **** #endif
 826:FWLIB/src/stm32f4xx_pwr.c ****   /* Request Wait For Interrupt */
 827:FWLIB/src/stm32f4xx_pwr.c ****   __WFI();
 828:FWLIB/src/stm32f4xx_pwr.c **** }
 829:FWLIB/src/stm32f4xx_pwr.c **** 
 830:FWLIB/src/stm32f4xx_pwr.c **** /**
 831:FWLIB/src/stm32f4xx_pwr.c ****   * @}
 832:FWLIB/src/stm32f4xx_pwr.c ****   */
 833:FWLIB/src/stm32f4xx_pwr.c **** 
 834:FWLIB/src/stm32f4xx_pwr.c **** /** @defgroup PWR_Group7 Flags management functions
 835:FWLIB/src/stm32f4xx_pwr.c ****  *  @brief   Flags management functions 
 836:FWLIB/src/stm32f4xx_pwr.c ****  *
 837:FWLIB/src/stm32f4xx_pwr.c **** @verbatim   
 838:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================
 839:FWLIB/src/stm32f4xx_pwr.c ****                     ##### Flags management functions #####
 840:FWLIB/src/stm32f4xx_pwr.c ****  ===============================================================================  
 841:FWLIB/src/stm32f4xx_pwr.c **** 
 842:FWLIB/src/stm32f4xx_pwr.c **** @endverbatim
 843:FWLIB/src/stm32f4xx_pwr.c ****   * @{
 844:FWLIB/src/stm32f4xx_pwr.c ****   */
 845:FWLIB/src/stm32f4xx_pwr.c **** 
 846:FWLIB/src/stm32f4xx_pwr.c **** /**
 847:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Checks whether the specified PWR flag is set or not.
 848:FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to check.
 849:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 850:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_WU: Wake Up flag. This flag indicates that a wakeup event 
 851:FWLIB/src/stm32f4xx_pwr.c ****   *                  was received from the WKUP pin or from the RTC alarm (Alarm A 
 852:FWLIB/src/stm32f4xx_pwr.c ****   *                  or Alarm B), RTC Tamper event, RTC TimeStamp event or RTC Wakeup.
 853:FWLIB/src/stm32f4xx_pwr.c ****   *                  An additional wakeup event is detected if the WKUP pin is enabled 
 854:FWLIB/src/stm32f4xx_pwr.c ****   *                  (by setting the EWUP bit) when the WKUP pin level is already high.  
 855:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_SB: StandBy flag. This flag indicates that the system was
 856:FWLIB/src/stm32f4xx_pwr.c ****   *                  resumed from StandBy mode.    
 857:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_PVDO: PVD Output. This flag is valid only if PVD is enabled 
 858:FWLIB/src/stm32f4xx_pwr.c ****   *                  by the PWR_PVDCmd() function. The PVD is stopped by Standby mode 
 859:FWLIB/src/stm32f4xx_pwr.c ****   *                  For this reason, this bit is equal to 0 after Standby or reset
 860:FWLIB/src/stm32f4xx_pwr.c ****   *                  until the PVDE bit is set.
 861:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_BRR: Backup regulator ready flag. This bit is not reset 
 862:FWLIB/src/stm32f4xx_pwr.c ****   *                  when the device wakes up from Standby mode or by a system reset 
 863:FWLIB/src/stm32f4xx_pwr.c ****   *                  or power reset.  
 864:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_VOSRDY: This flag indicates that the Regulator voltage 
 865:FWLIB/src/stm32f4xx_pwr.c ****   *                 scaling output selection is ready.
 866:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_ODRDY: This flag indicates that the Over-drive mode
 867:FWLIB/src/stm32f4xx_pwr.c ****   *                 is ready (STM32F42xxx/43xxx devices) 
 868:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_ODSWRDY: This flag indicates that the Over-drive mode
 869:FWLIB/src/stm32f4xx_pwr.c ****   *                 switcching is ready (STM32F42xxx/43xxx devices) 
 870:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_UDRDY: This flag indicates that the Under-drive mode
 871:FWLIB/src/stm32f4xx_pwr.c ****   *                 is enabled in Stop mode (STM32F42xxx/43xxx devices)
 872:FWLIB/src/stm32f4xx_pwr.c ****   * @retval The new state of PWR_FLAG (SET or RESET).
 873:FWLIB/src/stm32f4xx_pwr.c ****   */
ARM GAS  /tmp/cc74YnhY.s 			page 33


 874:FWLIB/src/stm32f4xx_pwr.c **** FlagStatus PWR_GetFlagStatus(uint32_t PWR_FLAG)
 875:FWLIB/src/stm32f4xx_pwr.c **** {
 630              		.loc 1 875 0
 631              		.cfi_startproc
 632              		@ args = 0, pretend = 0, frame = 0
 633              		@ frame_needed = 0, uses_anonymous_args = 0
 634              		@ link register save eliminated.
 635              	.LVL30:
 876:FWLIB/src/stm32f4xx_pwr.c ****   FlagStatus bitstatus = RESET;
 877:FWLIB/src/stm32f4xx_pwr.c ****   
 878:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 879:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_GET_FLAG(PWR_FLAG));
 880:FWLIB/src/stm32f4xx_pwr.c ****   
 881:FWLIB/src/stm32f4xx_pwr.c ****   if ((PWR->CSR & PWR_FLAG) != (uint32_t)RESET)
 636              		.loc 1 881 0
 637 0000 034B     		ldr	r3, .L67
 638 0002 5B68     		ldr	r3, [r3, #4]
 639 0004 0342     		tst	r3, r0
 640 0006 01D1     		bne	.L66
 882:FWLIB/src/stm32f4xx_pwr.c ****   {
 883:FWLIB/src/stm32f4xx_pwr.c ****     bitstatus = SET;
 884:FWLIB/src/stm32f4xx_pwr.c ****   }
 885:FWLIB/src/stm32f4xx_pwr.c ****   else
 886:FWLIB/src/stm32f4xx_pwr.c ****   {
 887:FWLIB/src/stm32f4xx_pwr.c ****     bitstatus = RESET;
 641              		.loc 1 887 0
 642 0008 0020     		movs	r0, #0
 643              	.LVL31:
 888:FWLIB/src/stm32f4xx_pwr.c ****   }
 889:FWLIB/src/stm32f4xx_pwr.c ****   /* Return the flag status */
 890:FWLIB/src/stm32f4xx_pwr.c ****   return bitstatus;
 891:FWLIB/src/stm32f4xx_pwr.c **** }
 644              		.loc 1 891 0
 645 000a 7047     		bx	lr
 646              	.LVL32:
 647              	.L66:
 883:FWLIB/src/stm32f4xx_pwr.c ****   }
 648              		.loc 1 883 0
 649 000c 0120     		movs	r0, #1
 650              	.LVL33:
 651 000e 7047     		bx	lr
 652              	.L68:
 653              		.align	2
 654              	.L67:
 655 0010 00700040 		.word	1073770496
 656              		.cfi_endproc
 657              	.LFE128:
 659              		.section	.text.PWR_ClearFlag,"ax",%progbits
 660              		.align	1
 661              		.global	PWR_ClearFlag
 662              		.syntax unified
 663              		.thumb
 664              		.thumb_func
 665              		.fpu softvfp
 667              	PWR_ClearFlag:
 668              	.LFB129:
 892:FWLIB/src/stm32f4xx_pwr.c **** 
ARM GAS  /tmp/cc74YnhY.s 			page 34


 893:FWLIB/src/stm32f4xx_pwr.c **** /**
 894:FWLIB/src/stm32f4xx_pwr.c ****   * @brief  Clears the PWR's pending flags.
 895:FWLIB/src/stm32f4xx_pwr.c ****   * @param  PWR_FLAG: specifies the flag to clear.
 896:FWLIB/src/stm32f4xx_pwr.c ****   *          This parameter can be one of the following values:
 897:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_WU: Wake Up flag
 898:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_SB: StandBy flag
 899:FWLIB/src/stm32f4xx_pwr.c ****   *            @arg PWR_FLAG_UDRDY: Under-drive ready flag (STM32F42xxx/43xxx devices)
 900:FWLIB/src/stm32f4xx_pwr.c ****   * @retval None
 901:FWLIB/src/stm32f4xx_pwr.c ****   */
 902:FWLIB/src/stm32f4xx_pwr.c **** void PWR_ClearFlag(uint32_t PWR_FLAG)
 903:FWLIB/src/stm32f4xx_pwr.c **** {
 669              		.loc 1 903 0
 670              		.cfi_startproc
 671              		@ args = 0, pretend = 0, frame = 0
 672              		@ frame_needed = 0, uses_anonymous_args = 0
 673              		@ link register save eliminated.
 674              	.LVL34:
 904:FWLIB/src/stm32f4xx_pwr.c ****   /* Check the parameters */
 905:FWLIB/src/stm32f4xx_pwr.c ****   assert_param(IS_PWR_CLEAR_FLAG(PWR_FLAG));
 906:FWLIB/src/stm32f4xx_pwr.c ****   
 907:FWLIB/src/stm32f4xx_pwr.c **** #if defined (STM32F427_437xx) || defined (STM32F429_439xx)
 908:FWLIB/src/stm32f4xx_pwr.c ****   if (PWR_FLAG != PWR_FLAG_UDRDY)
 909:FWLIB/src/stm32f4xx_pwr.c ****   {
 910:FWLIB/src/stm32f4xx_pwr.c ****     PWR->CR |=  PWR_FLAG << 2;
 911:FWLIB/src/stm32f4xx_pwr.c ****   }
 912:FWLIB/src/stm32f4xx_pwr.c ****   else
 913:FWLIB/src/stm32f4xx_pwr.c ****   {
 914:FWLIB/src/stm32f4xx_pwr.c ****     PWR->CSR |= PWR_FLAG_UDRDY;
 915:FWLIB/src/stm32f4xx_pwr.c ****   }
 916:FWLIB/src/stm32f4xx_pwr.c **** #endif /* STM32F427_437xx ||  STM32F429_439xx */
 917:FWLIB/src/stm32f4xx_pwr.c **** 
 918:FWLIB/src/stm32f4xx_pwr.c **** #if defined (STM32F40_41xxx) || defined (STM32F401xx) || defined (STM32F411xE) 
 919:FWLIB/src/stm32f4xx_pwr.c ****   PWR->CR |=  PWR_FLAG << 2;
 675              		.loc 1 919 0
 676 0000 024A     		ldr	r2, .L70
 677 0002 1368     		ldr	r3, [r2]
 678 0004 43EA8000 		orr	r0, r3, r0, lsl #2
 679              	.LVL35:
 680 0008 1060     		str	r0, [r2]
 681 000a 7047     		bx	lr
 682              	.L71:
 683              		.align	2
 684              	.L70:
 685 000c 00700040 		.word	1073770496
 686              		.cfi_endproc
 687              	.LFE129:
 689              		.text
 690              	.Letext0:
 691              		.file 3 "/usr/include/newlib/machine/_default_types.h"
 692              		.file 4 "/usr/include/newlib/sys/_stdint.h"
 693              		.file 5 "CORE/core_cm4.h"
 694              		.file 6 "USER/system_stm32f4xx.h"
 695              		.file 7 "USER/stm32f4xx.h"
 696              		.file 8 "FWLIB/inc/stm32f4xx_rcc.h"
ARM GAS  /tmp/cc74YnhY.s 			page 35


DEFINED SYMBOLS
                            *ABS*:0000000000000000 stm32f4xx_pwr.c
     /tmp/cc74YnhY.s:16     .text.PWR_DeInit:0000000000000000 $t
     /tmp/cc74YnhY.s:23     .text.PWR_DeInit:0000000000000000 PWR_DeInit
     /tmp/cc74YnhY.s:50     .text.PWR_BackupAccessCmd:0000000000000000 $t
     /tmp/cc74YnhY.s:57     .text.PWR_BackupAccessCmd:0000000000000000 PWR_BackupAccessCmd
     /tmp/cc74YnhY.s:72     .text.PWR_BackupAccessCmd:0000000000000008 $d
     /tmp/cc74YnhY.s:77     .text.PWR_PVDLevelConfig:0000000000000000 $t
     /tmp/cc74YnhY.s:84     .text.PWR_PVDLevelConfig:0000000000000000 PWR_PVDLevelConfig
     /tmp/cc74YnhY.s:108    .text.PWR_PVDLevelConfig:0000000000000010 $d
     /tmp/cc74YnhY.s:113    .text.PWR_PVDCmd:0000000000000000 $t
     /tmp/cc74YnhY.s:120    .text.PWR_PVDCmd:0000000000000000 PWR_PVDCmd
     /tmp/cc74YnhY.s:135    .text.PWR_PVDCmd:0000000000000008 $d
     /tmp/cc74YnhY.s:140    .text.PWR_WakeUpPinCmd:0000000000000000 $t
     /tmp/cc74YnhY.s:147    .text.PWR_WakeUpPinCmd:0000000000000000 PWR_WakeUpPinCmd
     /tmp/cc74YnhY.s:162    .text.PWR_WakeUpPinCmd:0000000000000008 $d
     /tmp/cc74YnhY.s:167    .text.PWR_BackupRegulatorCmd:0000000000000000 $t
     /tmp/cc74YnhY.s:174    .text.PWR_BackupRegulatorCmd:0000000000000000 PWR_BackupRegulatorCmd
     /tmp/cc74YnhY.s:189    .text.PWR_BackupRegulatorCmd:0000000000000008 $d
     /tmp/cc74YnhY.s:194    .text.PWR_MainRegulatorModeConfig:0000000000000000 $t
     /tmp/cc74YnhY.s:201    .text.PWR_MainRegulatorModeConfig:0000000000000000 PWR_MainRegulatorModeConfig
     /tmp/cc74YnhY.s:225    .text.PWR_MainRegulatorModeConfig:0000000000000010 $d
     /tmp/cc74YnhY.s:230    .text.PWR_OverDriveCmd:0000000000000000 $t
     /tmp/cc74YnhY.s:237    .text.PWR_OverDriveCmd:0000000000000000 PWR_OverDriveCmd
     /tmp/cc74YnhY.s:252    .text.PWR_OverDriveCmd:0000000000000008 $d
     /tmp/cc74YnhY.s:257    .text.PWR_OverDriveSWCmd:0000000000000000 $t
     /tmp/cc74YnhY.s:264    .text.PWR_OverDriveSWCmd:0000000000000000 PWR_OverDriveSWCmd
     /tmp/cc74YnhY.s:279    .text.PWR_OverDriveSWCmd:0000000000000008 $d
     /tmp/cc74YnhY.s:284    .text.PWR_UnderDriveCmd:0000000000000000 $t
     /tmp/cc74YnhY.s:291    .text.PWR_UnderDriveCmd:0000000000000000 PWR_UnderDriveCmd
     /tmp/cc74YnhY.s:317    .text.PWR_UnderDriveCmd:000000000000001c $d
     /tmp/cc74YnhY.s:322    .text.PWR_MainRegulatorLowVoltageCmd:0000000000000000 $t
     /tmp/cc74YnhY.s:329    .text.PWR_MainRegulatorLowVoltageCmd:0000000000000000 PWR_MainRegulatorLowVoltageCmd
     /tmp/cc74YnhY.s:353    .text.PWR_MainRegulatorLowVoltageCmd:0000000000000014 $d
     /tmp/cc74YnhY.s:358    .text.PWR_LowRegulatorLowVoltageCmd:0000000000000000 $t
     /tmp/cc74YnhY.s:365    .text.PWR_LowRegulatorLowVoltageCmd:0000000000000000 PWR_LowRegulatorLowVoltageCmd
     /tmp/cc74YnhY.s:389    .text.PWR_LowRegulatorLowVoltageCmd:0000000000000014 $d
     /tmp/cc74YnhY.s:394    .text.PWR_FlashPowerDownCmd:0000000000000000 $t
     /tmp/cc74YnhY.s:401    .text.PWR_FlashPowerDownCmd:0000000000000000 PWR_FlashPowerDownCmd
     /tmp/cc74YnhY.s:416    .text.PWR_FlashPowerDownCmd:0000000000000008 $d
     /tmp/cc74YnhY.s:421    .text.PWR_EnterSTOPMode:0000000000000000 $t
     /tmp/cc74YnhY.s:428    .text.PWR_EnterSTOPMode:0000000000000000 PWR_EnterSTOPMode
     /tmp/cc74YnhY.s:491    .text.PWR_EnterSTOPMode:0000000000000030 $d
     /tmp/cc74YnhY.s:499    .text.PWR_EnterUnderDriveSTOPMode:0000000000000000 $t
     /tmp/cc74YnhY.s:506    .text.PWR_EnterUnderDriveSTOPMode:0000000000000000 PWR_EnterUnderDriveSTOPMode
     /tmp/cc74YnhY.s:568    .text.PWR_EnterUnderDriveSTOPMode:0000000000000030 $d
     /tmp/cc74YnhY.s:576    .text.PWR_EnterSTANDBYMode:0000000000000000 $t
     /tmp/cc74YnhY.s:583    .text.PWR_EnterSTANDBYMode:0000000000000000 PWR_EnterSTANDBYMode
     /tmp/cc74YnhY.s:613    .text.PWR_EnterSTANDBYMode:0000000000000018 $d
     /tmp/cc74YnhY.s:621    .text.PWR_GetFlagStatus:0000000000000000 $t
     /tmp/cc74YnhY.s:628    .text.PWR_GetFlagStatus:0000000000000000 PWR_GetFlagStatus
     /tmp/cc74YnhY.s:655    .text.PWR_GetFlagStatus:0000000000000010 $d
     /tmp/cc74YnhY.s:660    .text.PWR_ClearFlag:0000000000000000 $t
     /tmp/cc74YnhY.s:667    .text.PWR_ClearFlag:0000000000000000 PWR_ClearFlag
     /tmp/cc74YnhY.s:685    .text.PWR_ClearFlag:000000000000000c $d
                     .debug_frame:0000000000000010 $d

ARM GAS  /tmp/cc74YnhY.s 			page 36


UNDEFINED SYMBOLS
RCC_APB1PeriphResetCmd
